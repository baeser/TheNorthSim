<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The North - Pre-WWI Simulation</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.8.2/jspdf.plugin.autotable.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel+Decorative:wght@700&family=Cinzel:wght@400;700&family=Roboto:wght@400;500&display=swap" rel="stylesheet">
    <style>
        /* Base page styles */
        body {
            font-family: 'Roboto', sans-serif;
            background-color: #8B1538; /* Dexter maroon */
            /* Remove or comment out the background-image line */
            /* background-image: url('data:image/svg+xml;charset=UTF-8,<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100" viewBox="0 0 100 100"><g fill-opacity="0.05"><rect x="50" width="50" height="50" /><rect y="50" width="50" height="50" /></g></svg>'); */
            margin: 0;
        }

        h1, h2, h3, h4, h5, h6 { font-family: 'Cinzel', serif; }

        /* Card (glass / elevated) */
        .card {
            background: rgba(255,255,255,0.8);
            backdrop-filter: blur(6px);
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 10px 15px -3px rgba(0,0,0,.1), 0 4px 6px -2px rgba(0,0,0,.05); /* shadow-lg */
            border: 1px solid rgba(0,0,0,.1);
            transition: box-shadow .3s ease, transform .3s ease; /* transition-all duration-300 */
        }
        .card:hover { box-shadow: 0 25px 30px -10px rgba(0,0,0,.25); }

        /* Buttons */
        .btn {
            padding: .5rem 1.5rem; /* px-6 py-2 */
            border-radius: .5rem; /* rounded-lg */
            font-weight: 700; /* font-bold */
            color: #fff;
            box-shadow: 0 2px 6px rgba(0,0,0,.15); /* shadow-md */
            transition: transform .15s ease, filter .15s ease, opacity .2s ease; /* transition-all duration-200 ease-in-out */
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: .5rem;
            cursor: pointer;
            border: none;
        }
        .btn:disabled { opacity: .5; cursor: not-allowed; }
        .btn:hover { transform: translateY(-2px) scale(1.02); }

        /* Button variants (gradients approximate Tailwind color palette) */
        .btn-primary { background: linear-gradient(135deg, #4f46e5, #1e1b4b); }
        .btn-secondary { background: linear-gradient(135deg, #4b5563, #111827); }
        .btn-danger { background: linear-gradient(135deg, #ef4444, #7f1d1d); }
        .btn-success { background: linear-gradient(135deg, #16a34a, #065f46); }
        .btn-warning { background: linear-gradient(135deg, #f59e0b, #92400e); color:#111; }

        /* Info box */
        .info-box {
            background: rgba(255,255,255,.7);
            padding: 1rem;
            border-radius: .5rem;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0,0,0,.05);
            border: 1px solid rgba(0,0,0,.1);
        }

        /* Modal backdrop */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,.7);
            backdrop-filter: blur(4px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        /* Tabs */
        .tab-btn {
            cursor: pointer;
            padding: 1rem 1.5rem; /* py-4 px-6 */
            border-bottom: 4px solid transparent;
            font-weight: 600;
            color: #6b7280; /* gray-500 */
            white-space: nowrap;
            transition: color .2s ease, border-color .2s ease;
        }
        .tab-btn:hover { color: #111827; border-color: #e5e7eb; }
        .tab-btn.active { color: #3730a3; border-color: #4338ca; } /* indigo */

        .tab-panel { display: none; }
        .tab-panel.active { display: block; }

        /* Banner heading override */
        #studentCountryBanner h1 {
            font-family: 'Cinzel Decorative', cursive;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.6);
        }

        /* Toast notifications */
        #toastContainer {
            position: fixed;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            flex-direction: column;
            gap: .5rem;
            z-index: 60;
        }
        .toast {
            padding: .75rem 1rem;
            border-radius: .5rem;
            box-shadow: 0 10px 15px -3px rgba(0,0,0,.1), 0 4px 6px -2px rgba(0,0,0,.05);
            color: #111827;
            background: #ffffff;
            border-left: 6px solid #6366f1; /* indigo */
            opacity: 0;
            transform: translateY(6px);
            transition: opacity .2s ease, transform .2s ease;
        }
        .toast.show { opacity: 1; transform: translateY(0); }
        .toast.info { border-left-color: #6366f1; }
        .toast.success { border-left-color: #16a34a; }
        .toast.warning { border-left-color: #f59e0b; }
        .toast.error { border-left-color: #ef4444; }
    </style>
</head>
<body class="bg-gray-100">

    <div id="connectionStatus" class="fixed top-4 right-4 text-white text-sm font-bold py-1 px-3 rounded-full z-50 bg-yellow-500">Connecting...</div>

    <div id="loginScreen" class="fixed inset-0 bg-cover bg-center z-40 flex items-center justify-center p-4" style="background: linear-gradient(135deg, #8B1538, #6B0F2A);">
        <div class="bg-white bg-opacity-90 p-8 rounded-2xl shadow-2xl w-full max-w-md text-center backdrop-blur-sm">
            <h2 class="text-3xl font-bold text-gray-800 mb-2">Welcome to The North</h2>
            <p class="text-gray-600 mb-6">A game of national pride and international power.</p>
            <button id="signInBtn" class="btn btn-primary w-full text-lg py-3 flex items-center justify-center gap-3">
                <svg class="w-6 h-6" viewBox="0 0 48 48"><path fill="#FFC107" d="M43.611 20.083H42V20H24v8h11.303c-1.649 4.657-6.08 8-11.303 8c-6.627 0-12-5.373-12-12s5.373-12 12-12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C12.955 4 4 12.955 4 24s8.955 20 20 20s20-8.955 20-20c0-1.341-.138-2.65-.389-3.917z"></path><path fill="#FF3D00" d="M6.306 14.691l6.571 4.819C14.655 15.108 18.961 12 24 12c3.059 0 5.842 1.154 7.961 3.039l5.657-5.657C34.046 6.053 29.268 4 24 4C16.318 4 9.656 8.337 6.306 14.691z"></path><path fill="#4CAF50" d="M24 44c5.166 0 9.86-1.977 13.409-5.192l-6.19-5.238C29.211 35.091 26.715 36 24 36c-5.202 0-9.619-3.317-11.283-7.946l-6.522 5.025C9.505 39.556 16.227 44 24 44z"></path><path fill="#1976D2" d="M43.611 20.083H42V20H24v8h11.303c-.792 2.237-2.231 4.166-4.087 5.571l6.19 5.238C42.012 36.49 44 30.861 44 24c0-1.341-.138-2.65-.389-3.917z"></path></svg>
                Sign In with Google
            </button>
            <p id="loginError" class="text-red-500 mt-4 font-semibold"></p>
        </div>
    </div>

    <div id="rosterScreen" class="hidden fixed inset-0 bg-gray-200 z-30 flex items-center justify-center p-4">
        <div class="card p-8 w-full max-w-4xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-2xl font-bold text-gray-800">Manage Student Roster</h2>
                <div class="text-sm text-gray-600">Class Code: <span id="rosterClassCode" class="font-semibold"></span></div>
            </div>
            
            <div class="bg-gray-50 p-4 rounded-lg mb-6">
                <h3 class="text-lg font-semibold mb-3">Add Students</h3>
                
                <div class="mb-4 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                    <h4 class="font-medium text-blue-800 mb-2">CSV Upload (Recommended for large classes)</h4>
                    <p class="text-sm text-blue-700 mb-3">Upload a CSV file with columns: Email, Country, Section (optional)</p>
                    <div class="flex items-center gap-4 mb-2">
                        <input type="file" id="csvFile" accept=".csv" class="px-3 py-2 border border-blue-300 rounded-lg">
                        <button onclick="uploadCSV()" class="btn btn-primary">Upload CSV</button>
                        <button onclick="downloadTemplate()" class="btn btn-secondary text-sm">Download Template</button>
                    </div>
                    <p class="text-xs text-blue-600">CSV format: student1@email.com,Tobermory,2A or student1@email.com,Tobermory</p>
                    <p class="text-xs text-blue-600">Multiple students can be assigned to the same country (teams)</p>
                </div>

                <div class="p-4 bg-gray-100 border border-gray-200 rounded-lg">
                    <h4 class="font-medium text-gray-700 mb-2">Manual Entry (Single Student)</h4>
                    <div class="grid grid-cols-1 md:grid-cols-4 gap-4">
                        <input type="email" id="studentEmail" placeholder="Student email address" class="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <select id="studentCountry" class="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="">-- Select Country --</option>
                            <option value="Tobermory">Tobermory</option>
                            <option value="Metz">Metz</option>
                            <option value="Omsk">Omsk</option>
                            <option value="Grenoble">Grenoble</option>
                            <option value="Klagenfurt">Klagenfurt</option>
                            <option value="Tivoli">Tivoli</option>
                            <option value="Razgrad">Razgrad</option>
                        </select>
                        <select id="studentPeriod" class="px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="">-- Select Period --</option>
                            <option value="1">Period 1</option>
                            <option value="2">Period 2</option>
                            <option value="3">Period 3</option>
                            <option value="4">Period 4</option>
                            <option value="5">Period 5</option>
                            <option value="6">Period 6</option>
                        </select>
                        <button onclick="addStudentToRoster()" class="btn btn-primary">Add Student</button>
                    </div>
                </div>
            </div>

            <div class="mb-6">
                <div class="flex justify-between items-center mb-3">
                    <h3 class="text-lg font-semibold">Current Roster</h3>
                    <button id="removeSelectedBtn" type="button" onclick="removeSelectedStudents()" class="btn btn-danger">Remove Selected</button>
                </div>
                <form id="rosterForm">
                    <div id="rosterList" class="space-y-2 min-h-[200px] max-h-[300px] overflow-y-auto border border-gray-200 rounded-lg p-4 bg-white">
                        <p class="text-gray-500 text-center">No students added yet</p>
                    </div>
                </form>
            </div>

            <div class="mb-6">
                <h3 class="text-lg font-semibold mb-3">Class Period Breakdown</h3>
                <div id="periodBreakdown" class="space-y-4">
                    </div>
            </div>

            <div class="bg-gray-50 p-4 rounded-lg">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-end">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Select Class Period to Start:</label>
                        <select id="classPeriodSelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500">
                            <option value="">-- Select Period --</option>
                        </select>
                    </div>
                    <div class="flex gap-3">
                        <button onclick="startSimulationDirectly()" class="btn btn-success flex-grow">Start Simulation</button>
                        <button onclick="clearAllRoster()" class="btn btn-danger">Clear All</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="classCodeScreen" class="hidden fixed inset-0 bg-gray-200 z-30 flex items-center justify-center p-4">
        <div class="card p-8 w-full max-w-sm text-center">
             <h2 class="text-2xl font-bold text-gray-800 mb-4">Enter Class Code</h2>
             <input type="text" id="classCodeInput" placeholder="e.g., HISTORY101" class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 uppercase">
             <button id="joinClassBtn" class="btn btn-primary w-full mt-4">Join / Create Simulation</button>
             <p id="classCodeError" class="text-red-500 mt-4 font-semibold"></p>
        </div>
    </div>

    <div id="gameContainer" class="hidden p-4 lg:p-6 max-w-7xl mx-auto">
        <div id="studentCountryBanner" class="hidden w-full h-48 lg:h-64 mb-6 rounded-xl shadow-2xl bg-cover bg-center flex items-center justify-center text-white relative overflow-hidden">
            <div class="absolute inset-0 bg-black/40"></div>
            <div id="bannerContent" class="z-10 flex items-center gap-4 lg:gap-8">
                <div id="bannerEmblem" class="w-16 h-16 lg:w-24 lg:h-24">
                </div>
                <h1 id="bannerCountryName" class="text-5xl md:text-7xl font-bold">Country Name</h1>
            </div>
        </div>
        
        <header id="mainHeader" class="card p-4 mb-6">
            <div class="flex flex-wrap justify-between items-center gap-4">
                <div>
                    <h1 class="text-3xl font-bold text-indigo-900">The North</h1>
                    <p class="text-gray-500">Class: <span id="displayClassCode" class="font-semibold"></span> | Player: <span id="displayPlayerName" class="font-semibold text-indigo-700"></span></p>
                </div>
                <div id="phaseIndicator" class="text-center bg-gray-500 text-white rounded-full px-6 py-2">
                    <div class="font-bold text-lg">Round <span id="currentRound">1</span></div>
                    <div class="text-sm" id="phaseText">Waiting for Teacher...</div>
                </div>
            </div>
        </header>

        <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-4 mb-6">
            <div class="info-box"><div class="text-sm text-indigo-800 font-semibold">Budget ($)</div><div id="countryBudget" class="text-xl font-bold text-indigo-900">0</div></div>
            <div class="info-box"><div class="text-sm text-indigo-800 font-semibold">Income / Round</div><div id="roundIncome" class="text-xl font-bold text-indigo-900">0</div></div>
            <div class="info-box"><div class="text-sm text-indigo-800 font-semibold">Army Units</div><div id="armyUnits" class="text-xl font-bold text-indigo-900">0</div></div>
            <div class="info-box"><div class="text-sm text-indigo-800 font-semibold">Navy Units</div><div id="navyUnits" class="text-xl font-bold text-indigo-900">0</div></div>
            <div class="info-box"><div class="text-sm text-indigo-800 font-semibold">Happiness</div><div id="happinessTopDisplay" class="text-xl font-bold text-indigo-900">100</div></div>
        </div>

        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
            <div id="studentColumn" class="lg:col-span-2 space-y-6">
                <div id="studentRoleInterface" class="card hidden">
                    <div class="border-b border-gray-200">
                        <nav id="roleTabs" class="flex flex-wrap -mb-px px-6 overflow-x-auto" aria-label="Tabs">
                        </nav>
                    </div>
                    <div id="roleTabContent" class="p-6">
                    </div>
                </div>

                <div id="actionCardTemplates" class="hidden">
                    <div id="treasuryCardTemplate">
                        <div class="card p-6 mb-6">
                            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">National Treasury</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
                                <div class="info-box bg-blue-100 p-4">
                                    <div class="text-sm text-blue-800 font-semibold">Total Country Budget</div>
                                    <div id="treasuryTotalBudget" class="text-2xl font-bold text-blue-900">$0</div>
                                </div>
                                <div class="info-box bg-red-100 p-4">
                                    <div class="text-sm text-red-800 font-semibold">Allocated Military Budget</div>
                                    <div id="treasuryMilitaryBudget" class="text-2xl font-bold text-red-900">$0</div>
                                </div>
                                <div class="info-box bg-yellow-100 p-4">
                                    <div class="text-sm text-yellow-800 font-semibold">Colonial Income / Round</div>
                                    <div id="treasuryColonialIncome" class="text-2xl font-bold text-yellow-900">$0</div>
                                </div>
                            </div>
                                                        <div class="mt-6">
                                                                <label for="militaryBudgetSlider" class="block font-medium text-gray-700">Military Budget Allocation: <span id="militaryBudgetPercentageDisplay" class="font-bold text-indigo-600">25%</span></label>
                                                                <input type="range" id="militaryBudgetSlider" min="0" max="100" value="25" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer" oninput="setMilitaryBudget(this.value)">

                                                                <div class="mt-4">
                                                                    <button id="lockMilitaryBudgetBtn" class="btn btn-primary w-full" onclick="lockMilitaryBudget()">
                                                                        Lock Military Budget & Notify Secretary of War
                                                                    </button>
                                                                    <p id="militaryBudgetLockNote" class="text-xs text-gray-600 mt-2 hidden">
                                                                        Military budget locked for this round. Secretary of War has been notified.
                                                                    </p>
                                                                </div>
                                                        </div>
                        </div>
                        <div class="card p-6">
                            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Colonial Investment Planning</h3>
                            <p class="text-sm text-gray-600 mb-4">Pay now to attempt colonization. Results are revealed by the teacher at the end of the round.</p>
                            <div id="colonialPlanning" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                </div>
                                <div class="mt-4">
                                    <h4 class="text-lg font-semibold text-gray-800 mb-2">Your Colonies</h4>
                                    <div id="myColoniesDisplay" class="space-y-2">
                                        <p class="text-gray-500">No colonies yet.</p>
                                    </div>
                                </div>
                        </div>
                    </div>
                    <div id="militaryCardTemplate">
                        <div class="card p-6">
                            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Department of War</h3>
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6 text-center">
                                <div class="bg-red-50 p-4 rounded-lg">
                                    <h4 class="font-semibold text-red-800">Total Military Budget</h4>
                                    <p id="warTotalBudget" class="text-2xl font-bold text-red-900">$0</p>
                                </div>
                                <div class="bg-green-50 p-4 rounded-lg">
                                    <h4 class="font-semibold text-green-800">Remaining Funds</h4>
                                    <p id="warRemainingBudget" class="text-2xl font-bold text-green-900">$0</p>
                                </div>
                            </div>
                            <div class="space-y-4">
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center bg-gray-50 p-4 rounded-lg">
                                    <div>
                                        <div class="font-bold text-lg">Army Regiment</div>
                                        <div class="text-sm text-gray-600">Cost: 750 $ per unit</div>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="number" id="armyQuantity-main" min="1" value="1" class="w-20 text-center border-gray-300 rounded-md">
                                        <button onclick="purchaseUnits('army', 'main')" class="btn btn-danger flex-grow">Purchase</button>
                                    </div>
                                </div>
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center bg-gray-50 p-4 rounded-lg">
                                    <div>
                                        <div class="font-bold text-lg">Naval Fleet</div>
                                        <div class="text-sm text-gray-600">Cost: 1000 $ per unit</div>
                                    </div>
                                    <div class="flex items-center gap-2">
                                        <input type="number" id="navyQuantity-main" min="1" value="1" class="w-20 text-center border-gray-300 rounded-md">
                                        <button onclick="purchaseUnits('navy', 'main')" class="btn btn-danger flex-grow">Purchase</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- end of #militaryCardTemplate -->

                    <div id="warDeclarationTemplate">
                        <div class="card p-6">
                            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Department of War - Military Operations</h3>
                            
                            <!-- Regular purchase interface (existing) -->
                            <div id="warPurchaseInterface">
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6 text-center">
                                    <div class="bg-red-50 p-4 rounded-lg">
                                        <h4 class="font-semibold text-red-800">Total Military Budget</h4>
                                        <p id="warTotalBudget-war" class="text-2xl font-bold text-red-900">$0</p>
                                    </div>
                                    <div class="bg-green-50 p-4 rounded-lg">
                                        <h4 class="font-semibold text-green-800">Remaining Funds</h4>
                                        <p id="warRemainingBudget-war" class="text-2xl font-bold text-green-900">$0</p>
                                    </div>
                                </div>
                                <div class="space-y-4">
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center bg-gray-50 p-4 rounded-lg">
                                        <div>
                                            <div class="font-bold text-lg">Army Regiment</div>
                                            <div class="text-sm text-gray-600">Cost: 750 $ per unit</div>
                                        </div>
                                    <div class="flex items-center gap-2">
                                        <input type="number" id="armyQuantity-war" min="1" value="1" class="w-20 text-center border-gray-300 rounded-md">
                                        <button onclick="purchaseUnits('army', 'war')" class="btn btn-danger flex-grow">Purchase</button>
                                    </div>
                                    </div>
                                    <div class="grid grid-cols-1 md:grid-cols-2 gap-4 items-center bg-gray-50 p-4 rounded-lg">
                                        <div>
                                            <div class="font-bold text-lg">Naval Fleet</div>
                                            <div class="text-sm text-gray-600">Cost: 1000 $ per unit</div>
                                        </div>
                                    <div class="flex items-center gap-2">
                                        <input type="number" id="navyQuantity-war" min="1" value="1" class="w-20 text-center border-gray-300 rounded-md">
                                        <button onclick="purchaseUnits('navy', 'war')" class="btn btn-danger flex-grow">Purchase</button>
                                    </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- War Declaration Interface (only shows after round 4) -->
                            <div id="warDeclarationInterface" class="hidden mt-6 pt-6 border-t-2 border-red-300">
                                <div class="bg-red-900 text-white p-4 rounded-lg mb-4">
                                    <h4 class="text-lg font-bold mb-2">⚔️ MILITARY AGGRESSION AUTHORIZED ⚔️</h4>
                                    <p class="text-sm">You may now declare war on rival alliances. Approval required from Secretary of State and Minister of Domestic Tranquility.</p>
                                </div>
                                <button onclick="showWarDeclarationModal()" class="btn btn-danger w-full text-lg py-4 bg-gradient-to-br from-red-700 to-red-900 hover:from-red-800 hover:to-black">
                                    DECLARE WAR
                                </button>
                                
                                <!-- Show pending war declarations -->
                                <div id="pendingWarDeclarations" class="mt-4 hidden">
                                    <h5 class="font-semibold text-gray-700 mb-2">Pending War Declarations (Awaiting Approval):</h5>
                                    <div id="pendingWarList" class="space-y-2">
                                        <!-- Populated dynamically -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Add approval interfaces for Secretary of State and Minister -->
                    <div id="warApprovalTemplate">
                        <div class="p-6">
                            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">War Declaration Approval</h3>
                            <div id="warApprovalContent">
                                <p class="text-gray-600 mb-4">You must approve any declarations of war from your country before they are finalized.</p>
                                <div class="war-approval-list space-y-3">
                                    <!-- Populated dynamically -->
                                </div>
                            </div>
                            <div class="no-war-approvals text-gray-500 text-center py-8">
                                <p>No war declarations pending your approval.</p>
                            </div>
                        </div>
                    </div>
                    <div id="allianceCardTemplate">
                        <div class="card p-6">
                            <div id="allianceWarApprovalSection" class="hidden mb-6 border-2 border-red-300 pt-4 bg-red-50 p-4 rounded-lg">
                                <!-- War approval content will be injected here -->
                            </div>
                            <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Alliances</h3>
                            <p class="text-sm text-gray-600 mb-4">Form alliances for mutual benefit. Beware of historical rivalries!</p>
                            <button class="btn btn-primary w-full" onclick="showAllianceModal()">Manage Alliances</button>
                            <div id="myAlliances" class="mt-4">
                                </div>
                        </div>
                    </div>
                    <div id="ministerCardTemplate">
                         <div class="card p-6 bg-gray-50">
                            <div id="ministerWarApprovalSection" class="hidden mb-6 border-2 border-red-300 pt-4 bg-red-50 p-4 rounded-lg">
                                <!-- War approval content will be injected here -->
                            </div>
                            <h3 class="text-xl font-bold text-gray-800 mb-2">Minister of Domestic Tranquility</h3>
                            <p class="text-gray-600 mb-4">Your duty is to manage national morale and pride. This is shown as the Happiness Index.</p>
                             <div class="bg-blue-50 p-4 rounded-lg mb-4">
                                <div class="flex justify-between items-center mb-2">
                                    <span class="font-semibold">Happiness Index:</span>
                                    <span id="happinessDisplay" class="text-2xl font-bold text-blue-900">100</span>
                                </div>
                                <div class="w-full bg-gray-200 rounded-full h-4">
                                    <div id="happinessBar" class="bg-gradient-to-r from-red-500 via-yellow-500 to-green-500 h-4 rounded-full transition-all duration-500" style="width: 100%"></div>
                                </div>
                            </div>
                            <div class="space-y-4">
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <label class="block font-medium text-gray-700 mb-2">
                                        Healthcare: <span id="healthcarePercent" class="font-bold text-indigo-600">20%</span>
                                        <span id="healthcareDollars" class="text-sm text-gray-600 ml-2">($0)</span>
                                    </label>
                                    <input type="range" id="healthcareSlider" min="0" max="50" value="20" class="w-full h-2 bg-gray-200 rounded-lg cursor-pointer" oninput="updateDomesticSpending()">
                                </div>
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <label class="block font-medium text-gray-700 mb-2">
                                        Education: <span id="educationPercent" class="font-bold text-indigo-600">20%</span>
                                        <span id="educationDollars" class="text-sm text-gray-600 ml-2">($0)</span>
                                    </label>
                                    <input type="range" id="educationSlider" min="0" max="50" value="20" class="w-full h-2 bg-gray-200 rounded-lg cursor-pointer" oninput="updateDomesticSpending()">
                                </div>
                                <div class="bg-gray-50 p-4 rounded-lg">
                                    <label class="block font-medium text-gray-700 mb-2">
                                        Infrastructure: <span id="infrastructurePercent" class="font-bold text-indigo-600">20%</span>
                                        <span id="infrastructureDollars" class="text-sm text-gray-600 ml-2">($0)</span>
                                    </label>
                                    <input type="range" id="infrastructureSlider" min="0" max="50" value="20" class="w-full h-2 bg-gray-200 rounded-lg cursor-pointer" oninput="updateDomesticSpending()">
                                </div>
                            </div>
                            <div id="domesticWarnings" class="mt-4 space-y-2"></div>
                            <button onclick="saveDomesticBudget()" class="btn btn-success w-full mt-4">Save Domestic Budget</button>
                            
                            <div class="border-t pt-4 mt-4">
                                <h4 class="text-lg font-semibold text-gray-800 mb-3">Active National Events</h4>
                                <div id="activeEventsList" class="space-y-2 max-h-40 overflow-y-auto">
                                    <p class="text-gray-500">No active events.</p>
                                </div>
                            </div>

                            <div class="border-t pt-4 mt-4">
                                <h4 class="text-lg font-semibold text-gray-800 mb-3">National Flag</h4>
                                <div class="flex flex-col md:flex-row items-center gap-4">
                                    <div class="w-48 h-28 bg-gray-200 rounded-md flex items-center justify-center border-2 border-dashed">
                                        <img id="flagPreview" src="https://placehold.co/192x112/e2e8f0/94a3b8?text=No+Flag" alt="Flag preview" class="w-full h-full object-cover rounded-md">
                                    </div>
                                    <div class="flex-grow">
                                        <label for="flagUploader" class="block text-sm font-medium text-gray-700 mb-2">Select a new flag image (max 1MB):</label>
                                        <input type="file" id="flagUploader" accept="image/*" class="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 file:text-indigo-700 hover:file:bg-indigo-100"/>
                                        <button id="uploadFlagBtn" onclick="uploadFlag()" class="btn btn-primary mt-3">Upload Flag</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="space-y-6">
                <div id="teacherPanel" class="card p-6 hidden">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Teacher Controls</h3>
                    <div class="space-y-3">
                         <div class="text-center p-3 rounded-lg bg-indigo-50 border border-indigo-200">
                            <label for="timerMinutes" class="font-semibold text-indigo-800">Round Timer</label>
                            <div class="flex justify-center items-center gap-2 mt-1">
                                <input type="number" id="timerMinutes" value="15" min="1" class="w-20 text-center border-gray-300 rounded-md">
                                <span class="text-gray-600">minutes</span>
                            </div>
                        </div>
                        <div class="text-center p-3 rounded-lg bg-indigo-50 border border-indigo-200">
                            <label for="mobilizationMinutes" class="font-semibold text-indigo-800">Mobilization Length</label>
                            <div class="flex justify-center items-center gap-2 mt-1">
                                <input type="number" id="mobilizationMinutes" value="15" min="5" max="60" class="w-20 text-center border-gray-300 rounded-md">
                                <span class="text-gray-600">minutes for mobilization</span>
                            </div>
                        </div>
                        <button id="startRoundBtn" onclick="startRound()" class="btn btn-success w-full">1. Start Round</button>
                        <!-- Add AFTER the "Start Round" button -->
                        <button onclick="initializeBudgetsForCurrentPeriod()" class="btn btn-primary w-full bg-purple-600 hover:bg-purple-700">
                            Initialize Player Budgets
                        </button>
                        <button id="endRoundBtn" onclick="endRound()" class="btn btn-warning w-full">2. End Round & Lock Actions</button>
                        <button id="colonialChanceBtn" onclick="resolveColonialChance()" class="btn btn-primary w-full">3. Resolve Colonial Chance</button>
                        <button id="checkAlliancesBtn" onclick="checkAlliances()" class="btn btn-primary w-full">4. Check Alliances</button>
                        <button onclick="showTeacherWarManagement()" class="btn btn-secondary w-full">Manage Active Wars</button>
                        <button id="nextRoundBtn" onclick="nextRound()" class="btn btn-success w-full bg-purple-600 hover:bg-purple-700">5. Advance to Next Round</button>
                        
                        <hr class="my-3">
                        <button onclick="showTeacherRoleEditor()" class="btn btn-secondary w-full">Edit Roles</button>
                        <button onclick="showPnpPanel()" class="btn btn-secondary w-full">Award/Deduct PNP</button>
                        <button onclick="exportResults()" class="btn btn-secondary w-full bg-teal-600 hover:bg-teal-700">Export Results (PDF)</button>
                        <button onclick="resetGame()" class="btn btn-danger w-full mt-4">Reset Full Game</button>
                    </div>
                </div>
                 <div class="card p-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Country Log</h3>
                    <div id="eventLog" class="space-y-2 max-h-60 overflow-y-auto pr-2 text-sm">
                       <p class="text-gray-500">No events yet.</p>
                    </div>
                </div>

                <div class="card p-6">
                    <h3 class="text-xl font-bold text-gray-800 mb-4 border-b pb-2">Power Rankings</h3>
                    <div id="leaderboardList" class="space-y-2 max-h-96 overflow-y-auto pr-2">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="warDeclarationModal" class="modal-backdrop hidden">
        <div class="card p-6 w-full max-w-2xl m-4 max-h-[80vh] overflow-y-auto">
            <h3 class="text-2xl font-bold text-red-800 mb-4">⚔️ Declaration of War</h3>
            
            <div class="bg-yellow-100 border-2 border-yellow-400 rounded-lg p-4 mb-4">
                <p class="text-sm font-semibold text-yellow-800">⚠️ WARNING: This action will declare war on all selected nations!</p>
                <p class="text-xs text-yellow-700 mt-1">Requires unanimous approval from Secretary of State and Minister of Domestic Tranquility</p>
            </div>
            
            <div class="mb-4">
                <h4 class="font-semibold text-gray-700 mb-2">Enemy Alliances:</h4>
                <div id="enemyAlliancesList" class="space-y-4">
                    <!-- Populated with enemy alliances -->
                </div>
            </div>
            
            <div class="mb-4">
                <label for="warJustification" class="block font-medium text-gray-700 mb-2">Justification for War (Optional):</label>
                <textarea id="warJustification" rows="3" placeholder="State your casus belli..." 
                    class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-red-500"></textarea>
            </div>
            
            <div class="flex justify-end gap-3 mt-6">
                <button class="btn btn-secondary" onclick="closeWarDeclarationModal()">Cancel</button>
                <button class="btn btn-danger" onclick="submitWarDeclaration()">Submit Declaration</button>
            </div>
        </div>
    </div>

    <div id="warNotificationModal" class="modal-backdrop hidden">
        <div class="card p-8 w-full max-w-md m-4 text-center bg-red-50 border-4 border-red-600">
            <h3 class="text-3xl font-bold text-red-800 mb-4">⚔️ WAR DECLARED! ⚔️</h3>
            <div id="warNotificationContent" class="space-y-4">
                <!-- Populated dynamically -->
            </div>
            <button onclick="acknowledgeWarDeclaration()" class="btn btn-danger mt-6 w-full py-3 text-lg">
                Acknowledge Declaration
            </button>
        </div>
    </div>

        <!-- Mobilization Modal -->
        <div id="mobilizationModal" class="modal-backdrop hidden">
            <div class="card p-6 w-full max-w-3xl m-4 max-h-[90vh] overflow-y-auto">
                <div id="mobilizationContent"></div>
            </div>
        </div>

    <div id="allianceModal" class="modal-backdrop hidden">
        <div class="card p-6 w-full max-w-lg m-4">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Form an Alliance</h3>
            <p class="text-sm text-gray-600 mb-4">Select countries to form an alliance with. Forming an alliance is mutual.</p>
            <div id="countryCheckboxes" class="space-y-2 max-h-60 overflow-y-auto border p-3 rounded-lg"></div>
            <div class="mt-6 flex justify-end gap-3">
                <button class="btn btn-secondary" onclick="closeAllianceModal()">Cancel</button>
                <button class="btn btn-success" onclick="proposeAlliance()">Confirm Alliances</button>
            </div>
        </div>
    </div>

    <div id="pnpPanel" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50 hidden">
        <div class="bg-red-900 text-white rounded-xl shadow-lg p-8 w-full max-w-2xl relative">
            <button onclick="closePnpPanel()" class="absolute top-4 right-4 text-gray-300 hover:text-white transition-colors">
                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
            <h3 class="text-3xl font-bold mb-6 text-center">Award or Deduct PNP</h3>
            <div class="space-y-6">
                <div>
                    <label for="pnpCountry" class="block text-lg font-medium text-gray-200 mb-2">Select Country:</label>
                    <select id="pnpCountry" class="w-full px-4 py-3 text-lg border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-black">
                        <option value="">-- Select a Country --</option>
                    </select>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                         <label for="pnpAmount" class="block text-lg font-medium text-gray-200 mb-2">Amount:</label>
                        <input type="number" id="pnpAmount" placeholder="e.g. 20 or -10" class="w-full px-4 py-3 text-lg border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-black">
                    </div>
                     <div>
                        <label for="pnpReasonDropdown" class="block text-lg font-medium text-gray-200 mb-2">Reason Template:</label>
                        <select id="pnpReasonDropdown" class="w-full px-4 py-3 text-lg border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-black" onchange="handleReasonChange()">
                            <option value="">-- Select a Reason --</option>
                            <option value="Citizen out of area">Citizen out of area</option>
                            <option value="Citizen on cell phone">Citizen on cell phone</option>
                            <option value="Citizen being annoying">Citizen being annoying</option>
                            <option value="Excellent diplomacy">Excellent diplomacy</option>
                            <option value="Good roleplay">Good roleplay</option>
                            <option value="Historical accuracy">Historical accuracy</option>
                            <option value="Leadership shown">Leadership shown</option>
                            <option value="Disruptive behavior">Disruptive behavior</option>
                            <option value="Out of character">Out of character</option>
                            <option value="Custom">Custom (enter below)</option>
                        </select>
                    </div>
                </div>
                <div>
                    <label for="pnpReason" class="block text-lg font-medium text-gray-200 mb-2">Final Reason:</label>
                    <input type="text" id="pnpReason" placeholder="Enter custom reason or edit selected reason" class="w-full px-4 py-3 text-lg border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-indigo-500 text-black">
                </div>
            </div>
            <div class="mt-8 flex justify-end gap-4">
                <button class="btn btn-danger text-lg px-8 py-3" onclick="closePnpPanel()">Cancel</button>
                <button class="btn btn-success text-lg px-8 py-3" onclick="awardPnpToCountry()">Submit</button>
            </div>
        </div>
    </div>
    
    <div id="hourSelectionModal" class="modal-backdrop hidden">
        <div class="card p-6 w-full max-w-md m-4">
            <h3 class="text-xl font-bold text-gray-800 mb-4">Select Class Hour</h3>
            <p class="text-sm text-gray-600 mb-4">Which class period are you teaching right now?</p>
            <div id="availableHours" class="space-y-2 mb-6">
                </div>
            <div class="flex justify-end gap-3">
                <button class="btn btn-secondary" onclick="closeHourSelection()">Cancel</button>
                <button class="btn btn-success" onclick="startSimulationWithHour()" id="startWithHourBtn" disabled>Start Simulation</button>
            </div>
        </div>
    </div>
    
    <div id="confirmModal" class="modal-backdrop hidden">
        <div class="card p-6 w-full max-w-sm m-4 text-center">
            <h3 id="confirmModalTitle" class="text-xl font-bold text-gray-800 mb-4">Are you sure?</h3>
            <p id="confirmModalBody" class="text-gray-600 mb-6"></p>
            <div class="flex justify-center gap-4">
                <button id="confirmCancelBtn" class="btn btn-secondary px-6">Cancel</button>
                <button id="confirmOkBtn" class="btn btn-danger px-6">Confirm</button>
            </div>
        </div>
    </div>

    <div id="infoModal" class="modal-backdrop hidden">
        <div class="card p-6 w-full max-w-2xl m-4 max-h-[80vh] overflow-y-auto">
            <h3 id="infoModalTitle" class="text-2xl font-bold text-gray-800 mb-4">Results</h3>
            <div id="infoModalBody" class="space-y-3"></div>
            <div class="mt-6 flex justify-end">
                <button class="btn btn-primary" onclick="closeInfoModal()">Close</button>
            </div>
        </div>
    </div>

    <div id="studentNotificationModal" class="modal-backdrop hidden">
        <div class="card p-8 w-full max-w-md m-4 text-center transform transition-all duration-300 scale-95 opacity-0">
            <h3 id="studentNotificationTitle" class="text-2xl font-bold text-gray-800 mb-4">Update from Teacher</h3>
            <div id="studentNotificationBody" class="text-lg text-gray-700 space-y-3">
            </div>
            <div class="mt-8">
                <button onclick="closeStudentNotificationModal()" class="btn btn-primary px-10 py-3 text-lg">OK</button>
            </div>
        </div>
    </div>

    <div id="roleAssignmentModal" class="modal-backdrop hidden">
        <div class="card p-6 w-full max-w-2xl m-4">
            <h3 class="text-2xl font-bold text-gray-800 mb-2">Assign Team Roles</h3>
            <div id="roleAssignCountryName" class="text-sm text-gray-600 mb-4">
                Round 1 setup: assign a role to each teammate. These can be changed later by the teacher if needed.
            </div>
            <div id="roleAssignmentList" class="space-y-3 max-h-[55vh] overflow-y-auto border rounded-lg p-3 bg-gray-50"></div>
            <div class="mt-6 flex justify-end gap-3">
                <button id="cancelRolesBtn" class="btn btn-secondary px-6" onclick="closeRoleAssignmentModal()">Cancel</button>
                <button id="saveRolesBtn" class="btn btn-success px-6" onclick="saveRoleAssignments()">Save Roles</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, GoogleAuthProvider, signInWithPopup } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, onSnapshot, collection, runTransaction, updateDoc, writeBatch, query, where, getDocs, deleteDoc, serverTimestamp, addDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadString, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";

        let db, auth, storage;
        let user; 
        let userId, isTeacher = false, currentClassCode, myCountryName;
        
        let gameStateUnsubscribe = null;
        let playersUnsubscribe = null;
        let logUnsubscribe = null;
        let notificationUnsubscribe = null;
        let countryDataUnsubscribe = null;
        let warDeclarationsUnsubscribe = null;

        let localGameState = {};
        let localPlayersState = {};
        let localCountryData = {};
        let localWarDeclarations = {};
        let iAmRoleCaptain = false;
        let roleAssignmentShown = false;
        let confirmResolve = null;
        let isTeacherEditingRoles = false;
        const APP_ID = 'default-north-sim';

        const firebaseConfig = {
            apiKey: "AIzaSyDxnJPzzE23ikC2aag0OKzsx1oG0fExI7I",
            authDomain: "the-north-1bffa.firebaseapp.com",
            databaseURL: "https://the-north-1bffa-default-rtdb.firebaseio.com",
            projectId: "the-north-1bffa",
            storageBucket: "the-north-1bffa.appspot.com",
            messagingSenderId: "610595088129",
            appId: "1:610595088129:web:838554a99867882a219d00"
        };

                // ==== Utility safety helpers (economy + DOM) ====
                function clamp(min, val, max){
                    val = Number(val);
                    if (!isFinite(val)) return min;
                    return Math.max(min, Math.min(max, val));
                }
                function toNumber(v, fallback=0){
                    const n = Number(v);
                    return isFinite(n) ? n : fallback;
                }
                // qs helper defined later with an optional root parameter
        
        const BASE_INCOME = 25;
    const COLONIAL_TERRITORIES = {
            'baw': { name: 'Baw', cost: 10000, income: 18, description: 'Gold mines, fish' },
            'rangoon': { name: 'Rangoon', cost: 20000, income: 15, description: 'Trade routes, forests' },
            'bauru': { name: 'Bauru', cost: 5000, income: 12, description: 'Sugar, cotton, coffee' },
            'tandil': { name: 'Tandil', cost: 10000, income: 14, description: 'Lush plains, food crops' },
            'abyssinia': { name: 'Abyssinia', cost: 15000, income: 16, description: 'Gold, metals, livestock' },
            'kamina': { name: 'Kamina', cost: 5000, income: 22, description: 'Rubber, gold, diamonds' }
        };
        const ALLIANCE_RESTRICTIONS = {
            'Tobermory': ['Metz', 'Klagenfurt', 'Tivoli'], 'Omsk': ['Metz', 'Klagenfurt', 'Tivoli'],
            'Grenoble': ['Metz', 'Klagenfurt', 'Tivoli'], 'Tivoli': ['Tobermory', 'Omsk', 'Grenoble', 'Razgrad'],
            'Metz': ['Tobermory', 'Omsk', 'Grenoble', 'Razgrad'], 'Klagenfurt': ['Tobermory', 'Omsk', 'Grenoble', 'Razgrad'],
            'Razgrad': ['Metz', 'Klagenfurt', 'Tivoli']
        };
        // Helper to provide default starting budgets and country list (replaces removed STARTING_BUDGETS constant)
        function getDefaultStartingBudget(country) {
            const map = {
                'Tobermory': 100000, 'Grenoble': 60000, 'Omsk': 75000, 'Metz': 100000,
                'Klagenfurt': 50000, 'Tivoli': 40000, 'Razgrad': 25000
            };
            return map[country] ?? null;
        }
        function getAllStartingCountries() {
            return ['Tobermory','Grenoble','Omsk','Metz','Klagenfurt','Tivoli','Razgrad'];
        }
        const STUDENT_ROLES = [
            { name: 'Secretary of the Treasury', contentId: 'treasuryCardTemplate' },
            { name: 'Secretary of War', contentId: 'militaryCardTemplate' },
            { name: 'Secretary of State', contentId: 'allianceCardTemplate' },
            { name: 'Ambassador', contentId: 'allianceCardTemplate' }, 
            { name: 'Minister of Domestic Tranquility', contentId: 'ministerCardTemplate' },
            { name: 'Historian', description: 'You are responsible for recording the events of your nation. Use the Country Log to track actions and outcomes.' },
            { name: 'Media Specialist', description: 'Your role is to craft the public image of your nation through unbiased reporting and press releases.' },
            { name: 'Director of Propaganda', description: 'Your objective is to influence other nations and bolster domestic support through compelling narratives, whether true or not.' }
        ];
        const COUNTRY_THEMES = {
            'Tobermory': {
                    banner: 'linear-gradient(135deg, #0a3d62, #1e5a8e)',
                    color: 'text-white',
                    emblem: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke-width="4" stroke="#e0e0e0" fill="none"><path d="M10 30 A 40 40 0 0 1 90 30" /><path d="M10 30 L10 90 A 40 40 0 0 0 50 90 A 40 40 0 0 0 90 90 L90 30" /><circle cx="50" cy="60" r="15" fill="#f9ca24"/></g></svg>`
                },
                'Metz': {
                    banner: 'linear-gradient(135deg, #4a1818, #7a1f1f)',
                    color: 'text-white',
                    emblem: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke-width="4" stroke="#e0e0e0" fill="none"><path d="M10 30 A 40 40 0 0 1 90 30" /><path d="M10 30 L10 90 A 40 40 0 0 0 50 90 A 40 40 0 0 0 90 90 L90 30" /><path d="M30 40 L70 80 M70 40 L30 80" stroke-width="8"/></g></svg>`
                },
                'Omsk': {
                    banner: 'linear-gradient(135deg, #222f3e, #1a2230)',
                    color: 'text-white',
                    emblem: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke-width="4" stroke="#e0e0e0" fill="none"><path d="M10 30 A 40 40 0 0 1 90 30" /><path d="M10 30 L10 90 A 40 40 0 0 0 50 90 A 40 40 0 0 0 90 90 L90 30" /><polygon points="50,40 65,70 35,70" fill="#c8d6e5"/></g></svg>`
                },
                'Grenoble': {
                    banner: 'linear-gradient(135deg, #1e3a8a, #12306b)',
                    color: 'text-white',
                    emblem: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke-width="4" stroke="#e0e0e0" fill="none"><path d="M10 30 A 40 40 0 0 1 90 30" /><path d="M10 30 L10 90 A 40 40 0 0 0 50 90 A 40 40 0 0 0 90 90 L90 30" /><path d="M50 40 L50 80 M30 60 L70 60" stroke-width="8"/></g></svg>`
                },
                'Klagenfurt': {
                    banner: 'linear-gradient(135deg, #8c7ae6, #6b57d1)',
                    color: 'text-white',
                    emblem: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke-width="4" stroke="#e0e0e0" fill="none"><path d="M10 30 A 40 40 0 0 1 90 30" /><path d="M10 30 L10 90 A 40 40 0 0 0 50 90 A 40 40 0 0 0 90 90 L90 30" /><circle cx="50" cy="60" r="10" /><circle cx="35" cy="60" r="10"/><circle cx="65" cy="60" r="10"/></g></svg>`
                },
                'Tivoli': {
                    banner: 'linear-gradient(135deg, #009432, #00692a)',
                    color: 'text-white',
                    emblem: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke-width="4" stroke="#e0e0e0" fill="none"><path d="M10 30 A 40 40 0 0 1 90 30" /><path d="M10 30 L10 90 A 40 40 0 0 0 50 90 A 40 40 0 0 0 90 90 L90 30" /><rect x="35" y="45" width="30" height="30" fill="#f1c40f"/></g></svg>`
                },
                'Razgrad': {
                    banner: 'linear-gradient(135deg, #d35400, #c84b00)',
                    color: 'text-white',
                    emblem: `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><g stroke-width="4" stroke="#e0e0e0" fill="none"><path d="M10 30 A 40 40 0 0 1 90 30" /><path d="M10 30 L10 90 A 40 40 0 0 0 50 90 A 40 40 0 0 0 90 90 L90 30" /><polygon points="50,40 70,75 30,75" stroke-width="8"/></g></svg>`
                }
        };

        document.addEventListener('DOMContentLoaded', () => {
            initializeApp(firebaseConfig);
            auth = getAuth();
            db = getFirestore();
            storage = getStorage();
            
            document.getElementById('signInBtn').onclick = signInWithGoogle;
            document.getElementById('joinClassBtn').onclick = joinSimulation;
            // Hour selection modal buttons
            document.getElementById('startWithHourBtn').onclick = startSimulationWithHour;
            document.getElementById('confirmCancelBtn').onclick = () => closeConfirmModal(false);
            document.getElementById('confirmOkBtn').onclick = () => closeConfirmModal(true);

            // Disable purchase buttons and domestic sliders until player data is ready
            ['armyQuantity-main','navyQuantity-main','armyQuantity-war','navyQuantity-war'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.setAttribute('disabled', 'disabled');
            });
            ['healthcareSlider','educationSlider','infrastructureSlider','militaryBudgetSlider'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.setAttribute('disabled', 'disabled');
            });

            const flagUploader = document.getElementById('flagUploader');
            if(flagUploader) {
                flagUploader.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if(file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            document.getElementById('flagPreview').src = event.target.result;
                        }
                        reader.readAsDataURL(file);
                    }
                });
            }
            
            onAuthStateChanged(auth, async (currentUser) => {
                user = currentUser;
                if (user) {
                        // Use email as the key since player documents are stored by email
                        userId = user.email;
                    const displayName = user.displayName || user.email || 'User';
                    updateConnectionStatus(true, `Signed in as ${displayName}`);
                    document.getElementById('loginScreen').classList.add('hidden');
                    document.getElementById('classCodeScreen').classList.remove('hidden');
                } else {
                    updateConnectionStatus(false, 'Disconnected');
                    document.getElementById('loginScreen').classList.remove('hidden');
                    document.getElementById('classCodeScreen').classList.add('hidden');
                    document.getElementById('gameContainer').classList.add('hidden');
                    cleanupListeners();
                }
            });
        });

        // Teacher-only function to initialize game rules in Firestore
        async function initializeGameRules() {
            if (!isTeacher) {
                console.error('Only teachers can initialize game rules');
                return;
            }
            
            try {
                const gameRulesRef = doc(db, `apps/${APP_ID}/gameRules/budgets`);
                
                // These values never leave the teacher's browser during setup
                const SECRET_BUDGETS = {
                    'Tobermory': 100000,
                    'Metz': 100000, 
                    'Omsk': 75000,
                    'Grenoble': 60000,
                    'Klagenfurt': 50000,
                    'Tivoli': 40000,
                    'Razgrad': 25000
                };
                
                await setDoc(gameRulesRef, {
                    startingBudgets: SECRET_BUDGETS,
                    lastUpdated: serverTimestamp(),
                    updatedBy: user.email
                });
                
                console.log('Game rules initialized successfully');
                return true;
            } catch (err) {
                console.error('Failed to initialize game rules:', err);
                return false;
            }
        }

        // =============== Military Purchases ===============
        const UNIT_COSTS = { army: 750, navy: 1000 };

                function getMilitaryBudgetNumbers(player) {
                    const me = player || (localPlayersState ? localPlayersState[userId] : null);
                    if (!me) return { pct: 0, dollars: 0, pool: 0, spent: 0, remaining: 0 };

                    const sliderEl = document.getElementById('militaryBudgetSlider');
                    const rawPct = (me && isFinite(Number(me.militaryBudgetPercentage)))
                        ? Number(me.militaryBudgetPercentage)
                        : toNumber(sliderEl?.value, 25);
                    const pct = clamp(0, rawPct, 100);

                    const dollars = toNumber(me?.dollars, 0);
                    const pool = Math.floor(dollars * pct / 100);
                    const spent = toNumber(me?.militarySpendingThisRound, 0);
                    const remaining = Math.max(0, pool - spent);

                    return { pct, dollars, pool, spent, remaining };
                }

        function renderWarBudgets() {
            const me = localPlayersState ? localPlayersState[userId] : null;
            const { pool, remaining } = getMilitaryBudgetNumbers(me);
            const ids = ['warTotalBudget', 'warTotalBudget-war'];
            const rids = ['warRemainingBudget', 'warRemainingBudget-war'];
            ids.forEach(id => { const el = document.getElementById(id); if (el) el.textContent = `$${pool.toLocaleString()}`; });
            rids.forEach(id => { const el = document.getElementById(id); if (el) el.textContent = `$${remaining.toLocaleString()}`; });
        }

        function renderTopStatsFromPlayer(p) {
            if (!p) return;
            const budgetEl = document.getElementById('countryBudget');
            const armyEl = document.getElementById('armyUnits');
            const navyEl = document.getElementById('navyUnits');
            if (budgetEl) budgetEl.textContent = Number(p.dollars||0).toLocaleString();
            if (armyEl) armyEl.textContent = String(p.army || 0);
            if (navyEl) navyEl.textContent = String(p.navy || 0);
            // Treasury card mirrors
            const tTot = document.getElementById('treasuryTotalBudget');
            if (tTot) tTot.textContent = `$${Number(p.dollars||0).toLocaleString()}`;
            const { pool } = getMilitaryBudgetNumbers(p);
            const tMil = document.getElementById('treasuryMilitaryBudget');
            if (tMil) tMil.textContent = `$${pool.toLocaleString()}`;
            // Colonial income total (support array or object shapes)
            const colonialIncomeEl = document.getElementById('treasuryColonialIncome');
            try {
                const coloniesRaw = p.colonies || [];
                let colonies = [];
                if (Array.isArray(coloniesRaw)) colonies = coloniesRaw;
                else if (typeof coloniesRaw === 'object' && coloniesRaw !== null) colonies = Object.values(coloniesRaw);
                const totalColIncome = colonies.reduce((s, c) => s + (Number(c.income || 0)), 0);
                if (colonialIncomeEl) colonialIncomeEl.textContent = `$${Number(totalColIncome).toLocaleString()}`;
            } catch (e) {
                if (colonialIncomeEl) colonialIncomeEl.textContent = `$0`;
            }
            renderWarBudgets();
        }

        // Called by slider oninput
        window.setMilitaryBudget = async function(value) {
            try {
                const me = localPlayersState ? localPlayersState[userId] : null;
                const pct = Number(value);
                // Update label immediately
                const lbl = document.getElementById('militaryBudgetPercentageDisplay');
                if (lbl) lbl.textContent = `${pct}%`;
                // Write to Firestore (debounced-ish by quick guard)
                const { playerRef } = getSimRefs();
                await updateDoc(playerRef(userId), { militaryBudgetPercentage: pct });
                // Re-render budgets using updated percent
                renderTopStatsFromPlayer({ ...me, militaryBudgetPercentage: pct });
            } catch (err) {
                console.error('setMilitaryBudget error', err);
                toast(`Failed to set military budget: ${err.message}`, 'error');
            }
        }

// ===== Military budget lock state (country-level) =====
function isMilitaryBudgetLockedForMyCountry(){
    const c = myCountryName;
    if (!c) return false;
    return Boolean(safeGet(localCountryData, c, 'militaryBudgetLocked'));
}

function renderTreasuryLockState(){
    const locked = isMilitaryBudgetLockedForMyCountry();
    const slider = document.getElementById('militaryBudgetSlider');
    const btn = document.getElementById('lockMilitaryBudgetBtn');
    const note = document.getElementById('militaryBudgetLockNote');
    if (slider) slider.toggleAttribute('disabled', locked);
    if (btn) {
        btn.toggleAttribute('disabled', locked);
        btn.textContent = locked
            ? 'Military Budget Locked'
            : 'Lock Military Budget & Notify Secretary of War';
    }
    if (note) note.classList.toggle('hidden', !locked);
}

// Prevent changing allocation after lock
const _origSetMilitaryBudget = window.setMilitaryBudget;
window.setMilitaryBudget = async function(value){
    if (isMilitaryBudgetLockedForMyCountry()) {
        toast('Military budget is locked for this round by Treasury.', 'warning');
        renderTreasuryLockState();
        return;
    }
    return _origSetMilitaryBudget.call(this, value);
};

// Notify all players with role 'Secretary of War' in my country
async function notifyWarSecretaries(message){
    try {
        const myC = myCountryName;
        if (!myC) return;
        const warRole = 'Secretary of War';
        const entries = Object.entries(localPlayersState || {});
            const targets = entries.filter(([,p]) => {
                if (!p || p.country !== myC) return false;
                if (p.role === warRole) return true;
                if (Array.isArray(p.roles) && p.roles.includes(warRole)) return true;
                if (p.assignedRole === warRole) return true;
                return false;
            });
        for (const [pid] of targets) {
            await sendNotification(pid, { type: 'info', message });
        }
    } catch(e){ console.error('notifyWarSecretaries error', e); }
}

// Treasury action: lock allocation & alert War to begin purchasing
window.lockMilitaryBudget = async function(){
    try {
        if (!myCountryName) { toast('Join a country first.', 'warning'); return; }
        if (isMilitaryBudgetLockedForMyCountry()) { renderTreasuryLockState(); return; }

        const me = localPlayersState ? localPlayersState[userId] : null;
        if (!me) { toast('Player not ready yet.', 'warning'); return; }

        const { playerRef, countryRef } = getSimRefs();
        // Ensure the current slider value is saved to the player
        const pctLabel = Number(document.getElementById('militaryBudgetSlider')?.value ?? me.militaryBudgetPercentage ?? 25);
        await updateDoc(playerRef(userId), { militaryBudgetPercentage: pctLabel });

        // Lock at the country level so ALL teammates see the same state
        await updateDoc(countryRef(myCountryName), {
            militaryBudgetLocked: true,
            militaryBudgetLockedAt: serverTimestamp(),
            militaryBudgetPct: pctLabel
        });

        renderTreasuryLockState();
        toast('Military budget locked. Secretary of War has been notified.', 'success');

        // Send teammate notification(s)
        await notifyWarSecretaries('Treasury has locked the military budget. You may now purchase units within the allocated funds.');

        // Refresh budget tiles
        renderWarBudgets();
    } catch(err){
        console.error('lockMilitaryBudget error', err);
        toast(`Failed to lock budget: ${err.message}`, 'error');
    }
};

        window.purchaseUnits = async function(kind, context) {
            try {
                if (!['army','navy'].includes(kind)) throw new Error('Unknown unit kind');
                const qtyInputId = `${kind}Quantity-${context}`;
                const qtyEl = reqEl(qtyInputId);
                const qty = Math.max(1, Math.floor(Number(qtyEl.value || 1)));
                const costPer = UNIT_COSTS[kind];
                const totalCost = qty * costPer;

                const me = localPlayersState ? localPlayersState[userId] : null;
                if (!me) { toast('Player not ready yet.', 'warning'); return; }

                                const { remaining } = getMilitaryBudgetNumbers(me);
                                // Defensive: require a valid remaining pool and enough funds
                                if (!isFinite(remaining) || remaining <= 0 || totalCost > remaining) {
                                    toast(`Not enough remaining military funds. Need $${totalCost.toLocaleString()}, have $${isFinite(remaining) ? remaining.toLocaleString() : '0'}.`, 'warning');
                                    return;
                                }
                const newDollars = Math.max(0, Number(me.dollars || 0) - totalCost);
                const newArmy = kind === 'army' ? Number(me.army || 0) + qty : Number(me.army || 0);
                const newNavy = kind === 'navy' ? Number(me.navy || 0) + qty : Number(me.navy || 0);
                const newSpent = Number(me.militarySpendingThisRound || 0) + totalCost;

                const { playerRef } = getSimRefs();
                await updateDoc(playerRef(userId), {
                    dollars: newDollars,
                    army: newArmy,
                    navy: newNavy,
                    militarySpendingThisRound: newSpent
                });

                // Local optimistic UI update
                if (localPlayersState && localPlayersState[userId]) {
                    localPlayersState[userId] = { ...localPlayersState[userId], dollars: newDollars, army: newArmy, navy: newNavy, militarySpendingThisRound: newSpent };
                }
                renderTopStatsFromPlayer(localPlayersState[userId]);
                renderWarBudgets();
                qtyEl.value = 1;
                toast(`${qty} ${kind === 'army' ? 'Army regiment' : 'Naval fleet'}${qty>1?'s':''} purchased for $${totalCost.toLocaleString()}.`, 'success');
            } catch (err) {
                console.error('purchaseUnits error', err);
                toast(`Purchase failed: ${err.message}`, 'error');
            }
        }

                // Ensure basic economic/player numeric fields exist before enabling controls
                async function ensurePlayerEconomyInitialized() {
                    try {
                        const me = localPlayersState ? localPlayersState[userId] : null;
                        if (!me) return;

                        const needsIncome  = !isFinite(Number(me.income));
                        const needsMBP     = !isFinite(Number(me.militaryBudgetPercentage));
                        
                        // CHANGED: Don't set dollars here - handled by teacher initialization
                        if (needsIncome || needsMBP || !isFinite(Number(me.militarySpendingThisRound))) {
                            const payload = {};
                            if (needsIncome)  payload.income  = BASE_INCOME;
                            if (needsMBP)     payload.militaryBudgetPercentage = 25;
                            if (me.army == null) payload.army = 0;
                            if (me.navy == null) payload.navy = 0;
                            if (!isFinite(Number(me.militarySpendingThisRound))) payload.militarySpendingThisRound = 0;

                            const { playerRef } = getSimRefs();
                            await updateDoc(playerRef(userId), payload);

                            localPlayersState[userId] = { ...me, ...payload };
                        }
                    } catch (e) {
                        console.error('ensurePlayerEconomyInitialized failed:', e);
                    }
                }

                // Enable player controls once player data is loaded and validated
                async function enablePlayerControlsIfReady() {
            try {
                let me = localPlayersState ? localPlayersState[userId] : null;
                if (!me) {
                    console.log('enablePlayerControlsIfReady: No player data yet');
                    return;
                }

                // Ensure numeric economy fields exist before enabling controls. This may write defaults to Firestore.
                await ensurePlayerEconomyInitialized();

                // Refresh local cache reference in case the initializer updated the player document.
                me = localPlayersState ? localPlayersState[userId] : me;

                // Basic validation: must have numeric dollars and income fields (indicates initialized player)
                if (!isFinite(Number(me.dollars)) || !isFinite(Number(me.income))) {
                    console.log('Player economy not initialized yet; waiting for snapshot write...');
                    return;
                }

                console.log('enablePlayerControlsIfReady: Enabling controls', {
                    dollars: me.dollars,
                    income: me.income,
                    country: me.country
                });

                // Enable quantity inputs
                ['armyQuantity-main','navyQuantity-main','armyQuantity-war','navyQuantity-war'].forEach(id => {
                    const el = document.getElementById(id); 
                    if (el) el.removeAttribute('disabled');
                });

                // Enable sliders
                ['healthcareSlider','educationSlider','infrastructureSlider','militaryBudgetSlider'].forEach(id => {
                    const el = document.getElementById(id); 
                    if (el) el.removeAttribute('disabled');
                });

                // Sync slider UI with stored percent if present
                const pct = Number(me.militaryBudgetPercentage ?? 25);
                const slider = document.getElementById('militaryBudgetSlider');
                const lbl = document.getElementById('militaryBudgetPercentageDisplay');
                if (slider) slider.value = String(pct);
                if (lbl) lbl.textContent = `${pct}%`;
                
                // Reflect lock state on Treasury UI (disables slider/button if locked)
                try { renderTreasuryLockState(); } catch (e) { /* ignore if not ready */ }

                // Enable purchase buttons
                document.querySelectorAll('button[onclick]').forEach(btn => {
                    try {
                        const onclick = btn.getAttribute('onclick') || '';
                        if (onclick.includes('purchaseUnits')) {
                            btn.removeAttribute('disabled');
                        }
                    } catch(e) {}
                });

                // Re-render top stats now that controls are enabled
                renderTopStatsFromPlayer(me);
            } catch (e) {
                console.error('enablePlayerControlsIfReady failed:', e);
            }
        }
        // Expose to window so other init code can call after snapshots
        Object.assign(window, { enablePlayerControlsIfReady, renderWarBudgets, renderTopStatsFromPlayer });

        // =============== Alliances ===============
        // Helper: return array of [playerId, playerData] for a given country
        function getCountryPlayers(countryName) {
            if (!countryName) return [];
            return Object.entries(localPlayersState || {}).filter(([,p]) => (p && p.country) === countryName);
        }

        // Helper: send a notification to a single player id
        async function sendNotification(toPlayerId, payload) {
            const { basePath } = getSimRefs();
            const notifCol = collection(db, `${basePath}/players/${toPlayerId}/notifications`);
            await addDoc(notifCol, { ...payload, createdAt: serverTimestamp() });
        }

        // Helper: delete a single notification by id for the current user
        async function deleteMyNotificationById(notificationId) {
            const { basePath } = getSimRefs();
            const refPath = `${basePath}/players/${userId}/notifications/${notificationId}`;
            await deleteDoc(doc(db, refPath));
        }

        function renderMyAlliancesList() {
            const container = document.getElementById('myAlliances');
            if (!container) return;
            const myCountry = myCountryName;
            const alliances = safeGet(localCountryData, myCountry, 'alliances') || {};
            const keys = Object.keys(alliances);
            if (!keys.length) {
                container.innerHTML = '<p class="text-gray-500">No alliances yet.</p>';
                return;
            }
            container.innerHTML = keys.sort().map(k => {
                const status = alliances[k];
                const badge = status === 'accepted' ? '<span class="ml-2 text-xs bg-green-100 text-green-800 px-2 py-0.5 rounded">accepted</span>' : '<span class="ml-2 text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded">pending</span>';
                return `<div class="flex items-center justify-between p-2 bg-gray-50 rounded">`+
                       `<div><span class="font-medium">${k}</span>${badge}</div>`+
                       `</div>`;
            }).join('');
        }

        // Open the alliance modal and populate checkboxes
        window.showAllianceModal = function() {
            try {
                const modal = document.getElementById('allianceModal');
                const list = document.getElementById('countryCheckboxes');
                const myCountry = myCountryName;
                if (!myCountry) { toast('Join a country first.', 'warning'); return; }

                const myAlliances = safeGet(localCountryData, myCountry, 'alliances') || {};
                const restricted = new Set(ALLIANCE_RESTRICTIONS[myCountry] || []);
                const allCountries = getAllStartingCountries();

                list.innerHTML = '';
                for (const c of allCountries) {
                    if (c === myCountry) continue;
                    const status = myAlliances[c]; // undefined | 'pending' | 'accepted'
                    const isRestricted = restricted.has(c);
                    const checked = status === 'accepted' || status === 'pending';
                    const disabledAttr = isRestricted ? 'disabled' : '';
                    const note = isRestricted ? `<span class="ml-2 text-xs bg-red-100 text-red-700 px-2 py-0.5 rounded">historical rivalry</span>`
                                              : status === 'accepted' ? `<span class="ml-2 text-xs bg-green-100 text-green-800 px-2 py-0.5 rounded">accepted</span>`
                                              : status === 'pending' ? `<span class="ml-2 text-xs bg-yellow-100 text-yellow-800 px-2 py-0.5 rounded">pending</span>`
                                              : '';
                    const row = document.createElement('label');
                    row.className = 'flex items-center justify-between p-2 bg-white rounded border';
                    row.innerHTML = `
                        <div class="flex items-center gap-3">
                            <input type="checkbox" value="${c}" ${checked ? 'checked' : ''} ${disabledAttr} class="h-4 w-4 text-indigo-600 border-gray-300 rounded">
                            <span class="font-medium text-gray-800">${c}</span>
                        </div>
                        <div>${note}</div>
                    `;
                    list.appendChild(row);
                }
                modal.classList.remove('hidden');
            } catch (err) {
                console.error('showAllianceModal error', err);
                toast(`Failed to open alliances: ${err.message}`, 'error');
            }
        };

        window.closeAllianceModal = function() {
            const modal = document.getElementById('allianceModal');
            modal?.classList.add('hidden');
        }

        // Propose alliances based on selected checkboxes
        window.proposeAlliance = async function() {
            try {
                const myCountry = myCountryName;
                if (!myCountry) { toast('Join a country first.', 'warning'); return; }
                const list = document.getElementById('countryCheckboxes');
                const checks = Array.from(list.querySelectorAll('input[type="checkbox"]'));
                const selected = checks.filter(c => c.checked && !c.disabled).map(c => c.value);

                const { countryRef } = getSimRefs();
                const myData = localCountryData[myCountry] || {};
                const currentAlliances = { ...(myData.alliances || {}) };
                const toNewlyPropose = selected.filter(c => !currentAlliances[c]);

                if (!toNewlyPropose.length) {
                    toast('No new alliances selected. Already up to date.', 'info');
                    return;
                }

                const batch = writeBatch(db);
                for (const target of toNewlyPropose) {
                    // Set pending on both countries
                    const theirs = localCountryData[target] || {};
                    const myRef = countryRef(myCountry);
                    const theirRef = countryRef(target);
                    const newMine = { ...(myData.alliances || {}), [target]: 'pending' };
                    const newTheirs = { ...(theirs.alliances || {}), [myCountry]: 'pending' };
                    batch.set(myRef, { alliances: newMine }, { merge: true });
                    batch.set(theirRef, { alliances: newTheirs }, { merge: true });
                }
                await batch.commit();

                // Notify all players of each target country
                for (const target of toNewlyPropose) {
                    for (const [pid] of getCountryPlayers(target)) {
                        await sendNotification(pid, {
                            type: 'alliance_request',
                            fromPlayerId: userId,
                            fromCountry: myCountry,
                            message: `${myCountry} proposes an alliance with ${target}.`
                        });
                    }
                }

                toast(`Sent alliance request${toNewlyPropose.length>1?'s':''} to ${toNewlyPropose.join(', ')}.`, 'success');
                renderMyAlliancesList();
                closeAllianceModal();
            } catch (err) {
                console.error('proposeAlliance error', err);
                toast(`Failed to propose alliances: ${err.message}`, 'error');
            }
        }

        // Accept an alliance request from a notification
        window.acceptAllianceRequest = async function(notificationId, fromPlayerId) {
            try {
                const myCountry = myCountryName;
                const fromPlayer = (localPlayersState || {})[fromPlayerId];
                const otherCountry = fromPlayer?.country;
                if (!myCountry || !otherCountry) { toast('Could not resolve countries.', 'error'); return; }

                const { countryRef } = getSimRefs();
                const batch = writeBatch(db);
                const mineRef = countryRef(myCountry);
                const theirRef = countryRef(otherCountry);
                const myAll = { ...(safeGet(localCountryData, myCountry, 'alliances') || {}), [otherCountry]: 'accepted' };
                const theirAll = { ...(safeGet(localCountryData, otherCountry, 'alliances') || {}), [myCountry]: 'accepted' };
                batch.set(mineRef, { alliances: myAll }, { merge: true });
                batch.set(theirRef, { alliances: theirAll }, { merge: true });
                await batch.commit();

                // Clean up only this notification
                await deleteMyNotificationById(notificationId);

                // Notify the proposer country players
                for (const [pid] of getCountryPlayers(otherCountry)) {
                    await sendNotification(pid, {
                        type: 'info',
                        message: `${myCountry} accepted your alliance proposal.`
                    });
                }

                toast(`Alliance with ${otherCountry} accepted.`, 'success');
                renderMyAlliancesList();
                closeStudentNotificationModal();
            } catch (err) {
                console.error('acceptAllianceRequest error', err);
                toast(`Failed to accept alliance: ${err.message}`, 'error');
            }
        }

        // Reject an alliance request from a notification
        window.rejectAllianceRequest = async function(notificationId, fromPlayerId) {
            try {
                const myCountry = myCountryName;
                const fromPlayer = (localPlayersState || {})[fromPlayerId];
                const otherCountry = fromPlayer?.country;
                if (!myCountry || !otherCountry) { toast('Could not resolve countries.', 'error'); return; }

                const { countryRef } = getSimRefs();
                const mineRef = countryRef(myCountry);
                const theirRef = countryRef(otherCountry);

                // Mark as rejected on my side (and remove from theirs to avoid confusion)
                const myAll = { ...(safeGet(localCountryData, myCountry, 'alliances') || {}) };
                const theirAll = { ...(safeGet(localCountryData, otherCountry, 'alliances') || {}) };
                myAll[otherCountry] = 'rejected';
                delete theirAll[myCountry];
                await setDoc(mineRef, { alliances: myAll }, { merge: true });
                await setDoc(theirRef, { alliances: theirAll }, { merge: true });

                // Clean up only this notification
                await deleteMyNotificationById(notificationId);

                // Notify proposer
                for (const [pid] of getCountryPlayers(otherCountry)) {
                    await sendNotification(pid, { type: 'info', message: `${myCountry} rejected your alliance proposal.` });
                }

                toast(`Alliance with ${otherCountry} rejected.`, 'warning');
                renderMyAlliancesList();
                closeStudentNotificationModal();
            } catch (err) {
                console.error('rejectAllianceRequest error', err);
                toast(`Failed to reject alliance: ${err.message}`, 'error');
            }
        }

        // Keep alliances list fresh whenever country data changes elsewhere
        Object.assign(window, { renderMyAlliancesList });

        // =============== War System ===============
        const WAR_APPROVER_ROLES = ['Secretary of State', 'Minister of Domestic Tranquility'];
        const WAR_DECLARE_ROLE = 'Secretary of War';

        function getMyRoles() {
            const me = localPlayersState ? localPlayersState[userId] : null;
            if (!me) return [];
            if (Array.isArray(me.roles)) return me.roles;
            if (typeof me.role === 'string' && me.role) return [me.role];
            return [];
        }
        function userHasRole(roleName) {
            return getMyRoles().some(r => r === roleName);
        }
        function listNonAlliedCountries(myCountry) {
            const alliances = safeGet(localCountryData, myCountry, 'alliances') || {};
            const allies = new Set(Object.keys(alliances).filter(k => alliances[k] === 'accepted'));
            return getAllStartingCountries().filter(c => c !== myCountry && !allies.has(c));
        }

        // --- Modal open/close ---
        window.showWarDeclarationModal = function () {
            try {
                const simRound = Number(localGameState.round || 1);
                if (simRound < 4) { toast('War declarations unlock in Round 4.', 'warning'); return; }
                if (!userHasRole(WAR_DECLARE_ROLE)) { toast('Only the Secretary of War may declare war.', 'warning'); return; }
                if (!myCountryName) { toast('Join a country first.', 'warning'); return; }

                const list = reqEl('enemyAlliancesList');
                list.innerHTML = '';
                const enemies = listNonAlliedCountries(myCountryName);
                if (!enemies.length) {
                    list.innerHTML = '<p class="text-gray-500">No eligible enemy countries (you are allied with everyone!).</p>';
                } else {
                    enemies.forEach(c => {
                        const row = document.createElement('label');
                        row.className = 'flex items-center justify-between p-2 bg-white rounded border';
                        row.innerHTML = `
                            <div class="flex items-center gap-3">
                                <input type="checkbox" value="${c}" class="h-4 w-4 text-red-600 border-gray-300 rounded">
                                <span class="font-medium text-gray-800">${c}</span>
                            </div>`;
                        list.appendChild(row);
                    });
                }
                reqEl('warJustification').value = '';
                reqEl('warDeclarationModal').classList.remove('hidden');
            } catch (err) {
                console.error('showWarDeclarationModal error', err);
                toast(`Failed to open war modal: ${err.message}`, 'error');
            }
        };
        window.closeWarDeclarationModal = function () {
            reqEl('warDeclarationModal').classList.add('hidden');
        };

        // --- Submit war declaration ---
        window.submitWarDeclaration = async function () {
            try {
                const targets = Array.from(reqEl('enemyAlliancesList').querySelectorAll('input[type="checkbox"]:checked')).map(c => c.value);
                if (!targets.length) { toast('Select at least one enemy country.', 'warning'); return; }
                const justification = reqEl('warJustification').value.trim();
                const { warDeclarationsColRef } = getSimRefs();

                const payload = {
                    declaringCountry: myCountryName,
                    targets,
                    justification: justification || null,
                    approvals: { state: false, minister: false },
                    status: 'pending',
                    createdBy: userId,
                    createdAt: serverTimestamp()
                };

                // =============== Role Summary Panel ===============
                window.renderRoleSummaryPanel = function() {
                    try {
                        const container = reqEl('teacherRoleSummary');
                        if (!container) return;
                        container.innerHTML = '<div class="text-gray-500">Loading role summary…</div>';

                        if (!localPlayersState || Object.keys(localPlayersState).length === 0) {
                            container.innerHTML = '<div class="text-gray-400 italic">No player data loaded.</div>';
                            return;
                        }

                        // Group players by country
                        const byCountry = {};
                        for (const [pid, pdata] of Object.entries(localPlayersState)) {
                            const c = pdata.country || 'Unassigned';
                            if (!byCountry[c]) byCountry[c] = [];
                            byCountry[c].push({ id: pid, ...pdata });
                        }

                        const sortedCountries = Object.keys(byCountry).sort();
                        let html = '';

                        sortedCountries.forEach(country => {
                            const players = byCountry[country];
                            html += `
                                <div class="bg-white border border-gray-300 rounded-lg p-4 mb-3">
                                    <div class="flex justify-between items-center mb-2">
                                        <h3 class="font-semibold text-lg text-gray-800">${country}</h3>
                                        <button
                                            class="text-sm text-blue-600 hover:underline"
                                            onclick="showRoleAssignmentModal('${country}')"
                                        >Edit Roles</button>
                                    </div>
                                    <table class="w-full text-sm border-t border-gray-200">
                                        <thead>
                                            <tr class="text-gray-600">
                                                <th class="text-left py-1">Name</th>
                                                <th class="text-left py-1">Email</th>
                                                <th class="text-left py-1">Role</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${players
                                                .map(
                                                    p => `
                                                        <tr class="border-t">
                                                            <td class="py-1">${p.displayName || '(No name)'}</td>
                                                            <td class="py-1 text-gray-500">${p.email || ''}</td>
                                                            <td class="py-1 font-medium">${p.role || '<span class="text-gray-400 italic">Unassigned</span>'}</td>
                                                        </tr>`
                                                )
                                                .join('')}
                                        </tbody>
                                    </table>
                                </div>
                            `;
                        });

                        container.innerHTML = html;
                    } catch (err) {
                        console.error('renderRoleSummaryPanel error', err);
                        toast(`Failed to render role summary: ${err.message}`, 'error');
                    }
                };

                // Optional helper to refresh automatically when data changes
                window.refreshRoleSummaryOnUpdate = function() {
                    try {
                        if (typeof setupFirestoreListeners === 'function') {
                            // attach once localPlayersState updates
                            const original = setupFirestoreListeners;
                            window.setupFirestoreListeners = function() {
                                original();
                                // Give Firestore listener a moment to sync before rendering
                                setTimeout(renderRoleSummaryPanel, 1200);
                            };
                        }
                    } catch (err) {
                        console.error('refreshRoleSummaryOnUpdate error', err);
                    }
                };
                            // =============== PNP Panel (9) ===============
                            window.showPNPPanel = async function(countryName) {
                                try {
                                    // Use the actual modal id (#pnpPanel) and find the internal body container.
                                    const modal = reqEl('pnpPanel');
                                    const body = modal.querySelector('#pnpPanelBody') || modal.querySelector('.space-y-6');
                                    if (!body) throw new Error('PNP panel body element not found');
                                    body.innerHTML = '<div class="text-gray-500">Loading PNP data...</div>';

                                    const { countryDocRef } = getSimRefs(countryName);
                                    const snap = await getDoc(countryDocRef);
                                    const data = snap.exists() ? snap.data() : {};

                                    // Base categories (tweak as needed)
                                    const categories = [
                                        { key: 'food', label: 'Food' },
                                        { key: 'energy', label: 'Energy' },
                                        { key: 'rawMaterials', label: 'Raw Materials' },
                                        { key: 'consumerGoods', label: 'Consumer Goods' },
                                    ];

                                    body.innerHTML = `
                                        <h3 class="font-semibold text-lg mb-3 text-gray-800">Production, Needs & Purchases for ${countryName}</h3>
                                        <div class="grid grid-cols-3 gap-4 text-sm font-medium text-gray-600 border-b pb-2 mb-2">
                                            <div>Category</div><div>Produced</div><div>Needed</div>
                                        </div>
                                        <div id="pnpInputs" class="space-y-2">
                                            ${categories.map(c => `
                                                <div class="grid grid-cols-3 gap-4 items-center border-b pb-2">
                                                    <div class="font-medium">${c.label}</div>
                                                    <input type="number" id="prod-${c.key}" value="${data.production?.[c.key] ?? 0}" class="pnp-input border px-2 py-1 rounded text-right" min="0">
                                                    <input type="number" id="need-${c.key}" value="${data.needs?.[c.key] ?? 0}" class="pnp-input border px-2 py-1 rounded text-right" min="0">
                                                </div>
                                            `).join('')}
                                        </div>
                                        <div class="mt-4 flex justify-end">
                                            <button onclick="savePNPData('${countryName}')" class="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Save</button>
                                        </div>
                                        <div id="pnpSummary" class="mt-4 text-sm text-gray-700 hidden"></div>
                                    `;

                                    modal.classList.remove('hidden');
                                } catch (err) {
                                    console.error('showPNPPanel error', err);
                                    toast(`Failed to open PNP Panel: ${err.message}`, 'error');
                                }
                            };

                            // Close modal
                            window.closePNPPanel = function() {
                                // Hide the panel container
                                reqEl('pnpPanel').classList.add('hidden');
                            };

                            // Save PNP data back to Firestore
                            window.savePNPData = async function(countryName) {
                                try {
                                    const { countryDocRef } = getSimRefs(countryName);
                                    const inputs = Array.from(document.querySelectorAll('#pnpInputs .pnp-input'));
                                    const production = {};
                                    const needs = {};

                                    inputs.forEach(inp => {
                                        const [type, key] = inp.id.split('-');
                                        const val = parseFloat(inp.value) || 0;
                                        if (type === 'prod') production[key] = val;
                                        if (type === 'need') needs[key] = val;
                                    });

                                    // Compute surpluses/deficits
                                    const surplus = {};
                                    Object.keys(production).forEach(k => {
                                        surplus[k] = production[k] - (needs[k] ?? 0);
                                    });

                                    await updateDoc(countryDocRef, {
                                        production,
                                        needs,
                                        surplus,
                                        lastUpdatedBy: user?.uid || null,
                                        updatedAt: serverTimestamp()
                                    });

                                    renderPNPSummary(production, needs, surplus);
                                    toast('PNP data saved successfully!', 'success');
                                } catch (err) {
                                    console.error('savePNPData error', err);
                                    toast(`Failed to save PNP data: ${err.message}`, 'error');
                                }
                            };

                            // Show read-only summary mode (after save or for teacher view)
                            window.renderPNPSummary = function(production, needs, surplus) {
                                const sumDiv = reqEl('pnpSummary');
                                if (!sumDiv) return;
                                sumDiv.classList.remove('hidden');

                                const rows = Object.keys(production).map(k => {
                                    const diff = surplus[k];
                                    const color = diff > 0 ? 'text-green-600' : diff < 0 ? 'text-red-600' : 'text-gray-700';
                                    const label = diff > 0 ? 'Surplus' : diff < 0 ? 'Deficit' : 'Balanced';
                                    return `
                                        <tr>
                                            <td class="px-2 py-1">${k}</td>
                                            <td class="px-2 py-1 text-right">${production[k]}</td>
                                            <td class="px-2 py-1 text-right">${needs[k]}</td>
                                            <td class="px-2 py-1 text-right ${color}">${diff}</td>
                                            <td class="px-2 py-1 text-xs text-gray-500">${label}</td>
                                        </tr>
                                    `;
                                }).join('');

                                sumDiv.innerHTML = `
                                    <h4 class="font-semibold mb-2">Summary</h4>
                                    <table class="w-full text-sm border-t border-gray-200">
                                        <thead class="text-gray-600">
                                            <tr><th>Category</th><th>Produced</th><th>Needed</th><th>Net</th><th>Status</th></tr>
                                        </thead>
                                        <tbody>${rows}</tbody>
                                    </table>
                                `;
                            };
                const ref = await addDoc(warDeclarationsColRef, payload);

                // Notify approvers (State + Minister) in my country
                for (const [pid, pdata] of Object.entries(localPlayersState || {})) {
                    if (!pdata || pdata.country !== myCountryName) continue;
                    const roles = Array.isArray(pdata.roles) ? pdata.roles : (pdata.role ? [pdata.role] : []);
                    if (roles.some(r => WAR_APPROVER_ROLES.includes(r))) {
                        await sendNotification(pid, {
                            type: 'war_approval_request',
                            warId: ref.id,
                            fromCountry: myCountryName,
                            targets,
                            message: `${myCountryName} seeks approval to declare war on ${targets.join(', ')}.`
                        });
                    }
                }

                toast('War declaration submitted for approval.', 'success');
                reqEl('warDeclarationModal').classList.add('hidden');
                loadPendingWarDeclarations();
                loadWarApprovals();
            } catch (err) {
                console.error('submitWarDeclaration error', err);
                toast(`Failed to submit: ${err.message}`, 'error');
            }
        };

        // --- Pending list for declarer ---
        window.loadPendingWarDeclarations = async function () {
            try {
                const container = reqEl('pendingWarList');
                container.innerHTML = '';
                const { warDeclarationsColRef } = getSimRefs();
                const snap = await getDocs(query(warDeclarationsColRef,
                    where('declaringCountry', '==', myCountryName),
                    where('status', '==', 'pending')
                ));
                if (snap.empty) { qs('#pendingWarDeclarations')?.classList.add('hidden'); return; }
                qs('#pendingWarDeclarations')?.classList.remove('hidden');

                snap.forEach(d => {
                    const data = d.data();
                    const row = document.createElement('div');
                    row.className = 'p-2 bg-yellow-50 border border-yellow-200 rounded';
                    row.innerHTML = `
                        <div class="flex items-center justify-between">
                            <div><span class="font-medium">${data.declaringCountry}</span> → ${data.targets.join(', ')}</div>
                            <span class="text-xs bg-yellow-200 text-yellow-800 px-2 py-0.5 rounded">awaiting approvals</span>
                        </div>`;
                    container.appendChild(row);
                });
            } catch (err) {
                console.error('loadPendingWarDeclarations error', err);
            }
        };

        // --- Approval queues for State/Minister ---
        window.loadWarApprovals = async function () {
            try {
                const myRoles = getMyRoles();
                const needApproval = myRoles.some(r => WAR_APPROVER_ROLES.includes(r));
                const allianceSection = document.getElementById('allianceWarApprovalSection');
                const ministerSection = document.getElementById('ministerWarApprovalSection');
                if (allianceSection) allianceSection.classList.add('hidden');
                if (ministerSection) ministerSection.classList.add('hidden');
                if (!needApproval) return;

                const { warDeclarationsColRef } = getSimRefs();
                const snap = await getDocs(query(warDeclarationsColRef,
                    where('declaringCountry', '==', myCountryName),
                    where('status', '==', 'pending')
                ));
                if (snap.empty) return;

                const blocks = [];
                snap.forEach(d => {
                    const data = d.data();
                    const youAre = myRoles.find(r => WAR_APPROVER_ROLES.includes(r));
                    const approved = youAre?.includes('State') ? data.approvals?.state : data.approvals?.minister;
                    blocks.push(`
                        <div class="p-3 bg-white rounded border flex items-center justify-between">
                            <div>
                                <div class="font-semibold">${data.declaringCountry} → ${data.targets.join(', ')}</div>
                                <div class="text-xs text-gray-500">Justification: ${data.justification || '—'}</div>
                            </div>
                            <div class="flex gap-2">
                                <button class="btn btn-success" ${approved ? 'disabled' : ''} onclick="approveWar('${d.id}')">Approve</button>
                                <button class="btn btn-danger" onclick="rejectWar('${d.id}')">Reject</button>
                            </div>
                        </div>`);
                });
                const html = `<h4 class="text-lg font-semibold mb-2">War Declarations Requiring Your Approval</h4>${blocks.join('')}`;

                if (myRoles.includes('Secretary of State') && allianceSection) {
                    allianceSection.innerHTML = html; allianceSection.classList.remove('hidden');
                }
                if (myRoles.includes('Minister of Domestic Tranquility') && ministerSection) {
                    ministerSection.innerHTML = html; ministerSection.classList.remove('hidden');
                }
            } catch (err) {
                console.error('loadWarApprovals error', err);
            }
        };

        // --- Approve / Reject ---
        window.approveWar = async function (warId) {
            try {
                const myRoles = getMyRoles();
                const isState = myRoles.includes('Secretary of State');
                const isMinister = myRoles.includes('Minister of Domestic Tranquility');
                if (!isState && !isMinister) { toast('You are not an approver.', 'warning'); return; }

                const { warDeclarationsColRef } = getSimRefs();
                const ref = doc(warDeclarationsColRef, warId);

                await runTransaction(db, async (tx) => {
                    const snap = await tx.get(ref);
                    if (!snap.exists()) throw new Error('Declaration missing');
                    const data = snap.data();
                    const approvals = { ...(data.approvals || {}) };
                    if (isState) approvals.state = true;
                    if (isMinister) approvals.minister = true;
                    let status = data.status;
                    if (approvals.state && approvals.minister) status = 'approved';
                    tx.update(ref, { approvals, status });
                });

                const final = (await getDoc(ref)).data();
                if (final.status === 'approved') {
                    // START MOBILIZATION instead of immediate war notifications
                    await startMobilizationPhase(warId);
                } else {
                    toast('Approval recorded.', 'success');
                }
                loadWarApprovals();
            } catch (err) {
                console.error('approveWar error', err);
                toast(`Failed to approve: ${err.message}`, 'error');
            }
        };

        // --- Reject war declaration ---
        window.rejectWar = async function (warId) {
            try {
                const { warDeclarationsColRef } = getSimRefs();
                const warRef = doc(warDeclarationsColRef, warId);

                // Read the declaration before removing so we can notify parties
                const warSnap = await getDoc(warRef);
                if (!warSnap.exists()) {
                    toast('War declaration not found.', 'warning');
                    await loadWarApprovals();
                    return;
                }

                const warData = warSnap.data() || {};

                // Remove the declaration
                await deleteDoc(warRef);

                // Notify the declaring country's players that their declaration was rejected
                const declaringCountry = warData.declaringCountry;
                if (declaringCountry) {
                    const players = getCountryPlayers(declaringCountry);
                    for (const [pid] of players) {
                        try {
                            await sendNotification(pid, {
                                type: 'info',
                                message: `Your war declaration was rejected by your ministers.`
                            });
                        } catch (e) {
                            console.warn('Failed to notify player', pid, e?.message || e);
                        }
                    }
                }

                // Also notify the original creator if available
                if (warData.createdBy && warData.createdBy !== userId) {
                    try {
                        await sendNotification(warData.createdBy, {
                            type: 'info',
                            message: `Your war declaration (from ${declaringCountry || 'your country'}) was rejected by the approvers.`
                        });
                    } catch (e) {
                        console.warn('Failed to notify creator', warData.createdBy, e?.message || e);
                    }
                }

                toast('War declaration rejected.', 'success');
                // Refresh approval lists and pending lists
                try { await loadWarApprovals(); } catch (e) {}
                try { await loadPendingWarDeclarations(); } catch (e) {}
            } catch (err) {
                console.error('rejectWar error', err);
                toast(`Failed to reject: ${err.message}`, 'error');
            }
        };

        function updateConnectionStatus(connected, message) {
            const statusEl = document.getElementById('connectionStatus');
            if (statusEl) {
                statusEl.textContent = message;
                statusEl.classList.remove('bg-green-500', 'bg-red-500', 'bg-yellow-500');
                if (connected) {
                    statusEl.classList.add('bg-green-500');
                } else {
                    statusEl.classList.add('bg-red-500');
                }
            }
        }

        function showError(elementId, message) {
            const errorEl = document.getElementById(elementId);
            if (errorEl) {
                errorEl.textContent = message;
            }
        }

        function showInfoModal(title, bodyHtml) {
            document.getElementById('infoModalTitle').textContent = title;
            document.getElementById('infoModalBody').innerHTML = bodyHtml;
            document.getElementById('infoModal').classList.remove('hidden');
        }

        window.closeInfoModal = function() {
            document.getElementById('infoModal').classList.add('hidden');
        }

        function showConfirmModal(title, body) {
            document.getElementById('confirmModalTitle').textContent = title;
            document.getElementById('confirmModalBody').innerHTML = body;
            document.getElementById('confirmModal').classList.remove('hidden');
            return new Promise(resolve => {
                confirmResolve = resolve;
            });
        }

        function closeConfirmModal(result) {
            document.getElementById('confirmModal').classList.add('hidden');
            if (confirmResolve) {
                confirmResolve(result);
                confirmResolve = null;
            }
        }

        // ========= Core Helpers =========
        // Safe nested getter: safeGet(obj, 'a', 'b', 'c') -> obj?.a?.b?.c
        function safeGet(obj, ...pathParts) {
            let cur = obj;
            for (const key of pathParts) {
                if (cur == null) return undefined;
                cur = cur[key];
            }
            return cur;
        }

        // Required element by id; throws with clear message if missing
        function reqEl(id) {
            const el = document.getElementById(id);
            if (!el) { throw new Error(`Required DOM element #${id} not found`); }
            return el;
        }

        // Optional querySelector helper on a root (defaults to document), returns null if not found
        function qs(selector, root = document) { return root.querySelector(selector); }

        // Returns common Firestore references for the current simulation
        function getSimRefs() {
            if (!db) throw new Error('Firestore not initialized');
            if (!currentClassCode) throw new Error('No active class code set');
            const basePath = `apps/${APP_ID}/simulations/${currentClassCode}`;
            const simRef = doc(db, `apps/${APP_ID}/simulations`, currentClassCode);
            const playersColRef = collection(db, `${basePath}/players`);
            const rosterColRef = collection(db, `${basePath}/roster`);
            const countryDataColRef = collection(db, `${basePath}/countryData`);
            const warDeclarationsColRef = collection(db, `${basePath}/warDeclarations`);
            const notificationsColRef = userId ? collection(db, `${basePath}/players/${userId}/notifications`) : null;
            const logsColRef = userId ? collection(db, `${basePath}/players/${userId}/log`) : null;
            // Convenience builders
            const playerRef = (pid = userId) => doc(db, `${basePath}/players`, pid);
            const countryRef = (countryName) => doc(db, `${basePath}/countryData`, countryName);
            return { simRef, playersColRef, rosterColRef, countryDataColRef, warDeclarationsColRef, notificationsColRef, logsColRef, playerRef, countryRef, basePath };
        }

        // Promise-based confirm wrapper
        async function confirmAction(title, bodyHtml) {
            const ok = await showConfirmModal(title, bodyHtml);
            return !!ok;
        }

        // Lightweight toast notifications (non-blocking)
        function ensureToastContainer() {
            let c = document.getElementById('toastContainer');
            if (!c) {
                c = document.createElement('div');
                c.id = 'toastContainer';
                document.body.appendChild(c);
            }
            return c;
        }
        function toast(message, type = 'info', timeoutMs = 3000) {
            const container = ensureToastContainer();
            const div = document.createElement('div');
            div.className = `toast ${type}`;
            div.innerHTML = message;
            container.appendChild(div);
            // animate in
            requestAnimationFrame(() => div.classList.add('show'));
            // auto dismiss
            const remove = () => {
                div.classList.remove('show');
                setTimeout(() => div.remove(), 200);
            };
            const t = setTimeout(remove, timeoutMs);
            // allow click to dismiss early
            div.addEventListener('click', () => { clearTimeout(t); remove(); });
            return div;
        }

        // Expose helpers to window for easier debugging/usage from inline handlers
        Object.assign(window, { safeGet, reqEl, qs, getSimRefs, confirmAction, toast });
        
        function showStudentNotificationModal(notificationData, notificationId) {
            const modal = document.getElementById('studentNotificationModal');
            const titleEl = document.getElementById('studentNotificationTitle');
            const bodyEl = document.getElementById('studentNotificationBody');
            if (notificationData.type === 'war_declared') {
                titleEl.textContent = '⚔️ WAR DECLARED!';
                bodyEl.innerHTML = `<p class="font-semibold">${notificationData.message}</p>`;
            } else if (notificationData.type === 'alliance_request') {
                titleEl.textContent = 'Alliance Request';
                bodyEl.innerHTML = `
                    <p class="font-semibold mb-4">${notificationData.fromCountry || notificationData.from} has proposed an alliance.</p>
                    <div class="flex gap-3 justify-center">
                        <button class="btn btn-success px-6" onclick="acceptAllianceRequest('${notificationId}','${notificationData.fromPlayerId}')">Accept</button>
                        <button class="btn btn-danger px-6" onclick="rejectAllianceRequest('${notificationId}','${notificationData.fromPlayerId}')">Reject</button>
                    </div>
                `;
            } else {
                titleEl.textContent = 'Update from Teacher';
                bodyEl.innerHTML = `<p class="font-semibold">${notificationData.message}</p>`;
            }

            modal.classList.remove('hidden');
            setTimeout(() => {
                modal.querySelector('.card').classList.remove('scale-95', 'opacity-0');
                modal.querySelector('.card').classList.add('scale-100', 'opacity-100');
            }, 10);
            // Remember which notification this modal corresponds to so closing can delete it
            try { modal.dataset.notificationId = notificationId || ''; } catch (e) {}
        }

        function showMobilizationNotification(warId, notificationId) {
            const modal = reqEl('studentNotificationModal');
            reqEl('studentNotificationTitle').textContent = '⚔️ MOBILIZATION REQUIRED';
            reqEl('studentNotificationBody').innerHTML = `
                <p class="font-semibold mb-4">Your nation is at war! You must mobilize your forces immediately.</p>
                <div class="flex gap-3">
                    <button onclick="openMobilizationFromNotification('${warId}', '${notificationId}')" 
                            class="btn btn-danger flex-1 py-3">
                        Mobilize Forces Now
                    </button>
                    <button onclick="closeStudentNotificationModal('${notificationId}')" 
                            class="btn btn-secondary flex-1">
                        Remind Me Later
                    </button>
                </div>
            `;
            modal.classList.remove('hidden');
            try { modal.dataset.notificationId = notificationId || ''; } catch (e) {}
        }

        window.openMobilizationFromNotification = async function(warId, notificationId) {
            await deleteMyNotificationById(notificationId);
            closeStudentNotificationModal();
            showMobilizationPanel(warId);
        };

        window.closeStudentNotificationModal = async function(notificationId = null) {
                            const modal = document.getElementById('studentNotificationModal');
                            modal.classList.add('hidden');

                            // If a specific notificationId is provided, or stored on the modal dataset, delete only that notification.
                            const notificationColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${userId}/notifications`);
                            const idToDelete = notificationId || (modal && modal.dataset ? modal.dataset.notificationId : null);
                            if (idToDelete) {
                                try {
                                    await deleteMyNotificationById(idToDelete);
                                } catch (e) {
                                    console.warn('Failed to delete notification', idToDelete, e?.message || e);
                                }
                                try { delete modal.dataset.notificationId; } catch (e) {}
                                return;
                            }

                            // Legacy: delete all notifications if no ID specified
                            const q = query(notificationColRef);
                            const snapshot = await getDocs(q);
                            const batch = writeBatch(db);
                            snapshot.docs.forEach(doc => batch.delete(doc.ref));
                            await batch.commit();
                };

        window.acknowledgeWarDeclaration = async function() {
            // Same as closeStudentNotificationModal
            await closeStudentNotificationModal();
        };


        // Load existing roster from database
        window.loadExistingRoster = async function() {
            const rosterListEl = document.getElementById('rosterList');
            const periodBreakdownEl = document.getElementById('periodBreakdown');
            const classPeriodSelectEl = document.getElementById('classPeriodSelect');
            
            try {
                const rosterColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/roster`);
                const snapshot = await getDocs(rosterColRef);
                
                if (snapshot.empty) {
                    rosterListEl.innerHTML = '<p class="text-gray-500 text-center">No students added yet</p>';
                    periodBreakdownEl.innerHTML = '<p class="text-gray-500">No students to display</p>';
                    return;
                }
                
                const students = [];
                snapshot.forEach(doc => {
                    students.push({ email: doc.id, ...doc.data() });
                });
                
                // Sort by email
                students.sort((a, b) => a.email.localeCompare(b.email));
                
                // Display roster list with checkboxes
                rosterListEl.innerHTML = students.map(student => `
                    <div class="flex items-center justify-between p-3 bg-gray-50 rounded-lg">
                        <label class="flex items-center flex-grow cursor-pointer">
                            <input type="checkbox" value="${student.email}" 
                                   class="h-4 w-4 rounded border-gray-300 text-indigo-600 mr-3">
                            <div class="flex-grow">
                                <span class="font-medium text-gray-800">${student.email}</span>
                                <span class="text-sm text-gray-600 ml-3">${student.country}</span>
                                ${student.period ? `<span class="text-xs text-gray-500 ml-2">(Period ${student.period})</span>` : ''}
                            </div>
                        </label>
                    </div>
                `).join('');
                
                // Create period breakdown
                const periodGroups = {};
                students.forEach(student => {
                    const period = student.period || 'Unassigned';
                    if (!periodGroups[period]) {
                        periodGroups[period] = [];
                    }
                    periodGroups[period].push(student);
                });
                
                // Sort periods
                const sortedPeriods = Object.keys(periodGroups).sort((a, b) => {
                    if (a === 'Unassigned') return 1;
                    if (b === 'Unassigned') return -1;
                    return parseInt(a) - parseInt(b);
                });
                
                periodBreakdownEl.innerHTML = sortedPeriods.map(period => {
                    const studentsInPeriod = periodGroups[period];
                    return `
                        <div class="bg-gray-50 p-3 rounded-lg">
                            <h4 class="font-semibold text-gray-800 mb-2">
                                ${period === 'Unassigned' ? 'Unassigned' : `Period ${period}`} 
                                (${studentsInPeriod.length} student${studentsInPeriod.length !== 1 ? 's' : ''})
                            </h4>
                            <div class="text-sm text-gray-600 space-y-1">
                                ${studentsInPeriod.map(s => `<div>${s.email} - ${s.country}</div>`).join('')}
                            </div>
                        </div>
                    `;
                }).join('');
                
                // Populate class period selector
                const assignedPeriods = sortedPeriods.filter(p => p !== 'Unassigned');
                classPeriodSelectEl.innerHTML = '<option value="">-- Select Period --</option>' +
                    assignedPeriods.map(p => `<option value="${p}">Period ${p}</option>`).join('');
                
            } catch (error) {
                console.error("Failed to load roster:", error);
                rosterListEl.innerHTML = `<p class="text-red-500">Error loading roster: ${error.message}</p>`;
            }
        };

        // =============== Roster / CSV ===============
        function normalizeEmail(email) {
            return (email || '').trim().toLowerCase();
        }
        // Update: Dexter-specific email validation constants and helpers
        const STUDENT_EMAIL_REGEX = /^[a-z]+\.[a-z]+@dexterschools\.org$/i;
        const TEACHER_EMAIL_REGEX = /^[a-z]+@dexterschools\.org$/i;

        // Email validation function
        function isValidDexterEmail(email) {
            if (!email || typeof email !== 'string') return false;
            
            const normalized = email.trim().toLowerCase();
            
            // Check if it's a valid teacher OR student email
            if (TEACHER_EMAIL_REGEX.test(normalized)) {
                // Teacher email (no period before @)
                const localPart = normalized.split('@')[0];
                return localPart.length > 0 && /^[a-z]+$/.test(localPart);
            }
            
            if (STUDENT_EMAIL_REGEX.test(normalized)) {
                // Student email (firstname.lastname format)
                const parts = normalized.split('@')[0].split('.');
                return parts.length === 2 && parts[0].length > 0 && parts[1].length > 0;
            }
            
            return false;
        }

        // Determine if email is teacher or student
        function isTeacherEmail(email) {
            if (!email) return false;
            const normalized = email.trim().toLowerCase();
            const localPart = normalized.split('@')[0];
            // Teacher emails have no period in the local part
            return !localPart.includes('.') && normalized.endsWith('@dexterschools.org');
        }

        // User-friendly error message generator
        function getEmailValidationError(email, context = 'student') {
            if (!email || !email.trim()) {
                return 'Email address is required.';
            }
            
            const normalized = email.trim().toLowerCase();
            
            if (!normalized.includes('@')) {
                return 'Email must include @ symbol.';
            }
            
            if (!normalized.endsWith('@dexterschools.org')) {
                return 'Email must end with @dexterschools.org';
            }
            
            const localPart = normalized.split('@')[0];
            
            // If expecting student but got teacher format
            if (context === 'student' && !localPart.includes('.')) {
                return 'Student email must be formatted as: firstname.lastname@dexterschools.org';
            }
            
            // If has period, validate student format
            if (localPart.includes('.')) {
                const parts = localPart.split('.');
                if (parts.length !== 2) {
                    return 'Email must have exactly one period before @dexterschools.org';
                }
                if (parts[0].length === 0) {
                    return 'First name is required before the period.';
                }
                if (parts[1].length === 0) {
                    return 'Last name is required after the period.';
                }
            }
            
            if (!/^[a-z.]+$/.test(localPart)) {
                return 'Email can only contain lowercase letters and periods.';
            }
            
            if (localPart.length === 0) {
                return 'Email username cannot be empty.';
            }
            
            return null; // Valid
        }
        function normalizeCountry(raw) {
            if (!raw) return '';
            const m = String(raw).trim().toLowerCase();
            const map = getAllStartingCountries().reduce((acc, k) => {
                acc[k.toLowerCase()] = k; return acc;
            }, {});
            return map[m] || '';
        }
        function parseCSV(text) {
            // Minimal CSV parser supporting commas inside quotes
            const rows = [];
            let i = 0, field = '', row = [], inQuotes = false;
            const pushField = () => { row.push(field); field = ''; };
            const pushRow = () => { rows.push(row); row = []; };
            while (i < text.length) {
                const ch = text[i];
                if (inQuotes) {
                    if (ch === '"') {
                        if (text[i+1] === '"') { field += '"'; i++; } else { inQuotes = false; }
                    } else { field += ch; }
                } else {
                    if (ch === '"') { inQuotes = true; }
                    else if (ch === ',') { pushField(); }
                    else if (ch === '\n' || ch === '\r') {
                        // handle CRLF/CR
                        if (ch === '\r' && text[i+1] === '\n') i++;
                        pushField();
                        // skip empty trailing line
                        if (row.length > 1 || (row.length === 1 && row[0].trim() !== '')) pushRow();
                    } else { field += ch; }
                }
                i++;
            }
            // last field/row
            if (field.length || row.length) { pushField(); pushRow(); }
            return rows;
        }

        async function uploadCSV() {
            try {
                const input = reqEl('csvFile');
                if (!input.files || !input.files[0]) {
                    toast('Select a CSV file first.', 'warning');
                    return;
                }
                const file = input.files[0];
                const text = await file.text();
                const rows = parseCSV(text);
                if (!rows.length) { toast('CSV appears empty.', 'warning'); return; }
                
                let startIdx = 0;
                const header = rows[0].map(h => h.trim().toLowerCase());
                const isHeader = header.includes('email') || header.includes('country');
                if (isHeader) startIdx = 1;

                const { rosterColRef } = getSimRefs();
                const toWrite = [];
                const errors = [];
                
                for (let r = startIdx; r < rows.length; r++) {
                    const [emailRaw, countryRaw, sectionRaw] = rows[r];
                    const email = normalizeEmail(emailRaw);
                    const country = normalizeCountry(countryRaw);
                    const period = (sectionRaw || '').toString().trim();
                    
                    if (!email) continue;
                    
                    // Check if this is a teacher email (shouldn't be in roster)
                    if (isTeacherEmail(email)) {
                        errors.push(`Row ${r+1}: ${email} appears to be a teacher email. Only student emails should be in the roster.`);
                        continue;
                    }
                    
                    // Validate student email format
                    const emailError = getEmailValidationError(email, 'student');
                    if (emailError) {
                        errors.push(`Row ${r+1}: ${email} - ${emailError}`);
                        continue;
                    }
                    
                    if (!country) {
                        errors.push(`Row ${r+1}: Invalid country "${countryRaw}" for ${email}`);
                        continue;
                    }
                    
                    toWrite.push({ id: email, data: { country, period: period || null } });
                }
                
                if (!toWrite.length) { 
                    const errorList = errors.length > 0 
                        ? '<ul class="text-xs list-disc list-inside mt-2">' + errors.map(e => `<li>${e}</li>`).join('') + '</ul>'
                        : '';
                    showInfoModal('No Valid Rows', `<p>No valid rows found to import.</p>${errorList}`);
                    return; 
                }

                let processed = 0;
                while (processed < toWrite.length) {
                    const chunk = toWrite.slice(processed, processed + 400);
                    const batch = writeBatch(db);
                    for (const item of chunk) {
                        const docRef = doc(rosterColRef, item.id);
                        batch.set(docRef, item.data, { merge: true });
                    }
                    await batch.commit();
                    processed += chunk.length;
                }
                
                let message = `<p>Successfully added ${toWrite.length} student(s) to the roster.</p>`;
                if (errors.length > 0) {
                    message += `<p class="mt-3 text-sm text-red-600">Errors (${errors.length}):</p><ul class="text-xs list-disc list-inside max-h-40 overflow-y-auto">`;
                    errors.forEach(err => {
                        message += `<li>${err}</li>`;
                    });
                    message += `</ul>`;
                }
                
                showInfoModal('CSV Upload Complete', message);
                await loadExistingRoster();
                reqEl('csvFile').value = '';
            } catch (err) {
                console.error('uploadCSV error', err);
                toast(`CSV upload failed: ${err.message}`, 'error');
            }
        }

        function downloadTemplate() {
            const header = 'Email,Country,Section\n';
            const example = [
                'student1@example.com,Tobermory,2',
                'student2@example.com,Grenoble,3',
                'student3@example.com,Omsk,'
            ].join('\n');
            const csv = header + example + '\n';
            const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = 'roster_template.csv';
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
        }

        window.addStudentToRoster = async function() {
            const emailInput = reqEl('studentEmail').value.trim();
            const email = normalizeEmail(emailInput);
            const country = normalizeCountry(reqEl('studentCountry').value);
            const period = (reqEl('studentPeriod').value || '').trim();
            
            // Check if teacher email was entered by mistake
            if (isTeacherEmail(email)) {
                showInfoModal('Teacher Email Detected', `<p>This appears to be a teacher email. Only student emails (firstname.lastname format) should be added to the roster.</p><p class="mt-2 text-sm text-gray-600">Example: john.smith@dexterschools.org</p>`);
                return;
            }
            
            // Validate student email
            const emailError = getEmailValidationError(email, 'student');
            if (emailError) {
                showInfoModal('Invalid Email', `<p>${emailError}</p><p class="mt-2 text-sm text-gray-600">Example: john.smith@dexterschools.org</p>`);
                return;
            }
            
            if (!country) { 
                toast('Select a valid country.', 'warning'); 
                return; 
            }
            
            try {
                const { rosterColRef } = getSimRefs();
                const ref = doc(rosterColRef, email);
                await setDoc(ref, { country, period: period || null }, { merge: true });
                toast('Student added to roster.', 'success');
                reqEl('studentEmail').value = '';
                reqEl('studentCountry').value = '';
                reqEl('studentPeriod').value = '';
                await loadExistingRoster();
            } catch (err) {
                console.error('addStudentToRoster error', err);
                toast(`Failed to add: ${err.message}`, 'error');
            }
        };

        async function removeSelectedStudents() {
            const checks = Array.from(reqEl('rosterList').querySelectorAll('input[type="checkbox"]:checked'));
            if (checks.length === 0) { toast('Select at least one student to remove.', 'warning'); return; }
            const ok = await confirmAction('Remove selected?', `<p>You are about to remove <strong>${checks.length}</strong> student(s) from the roster.</p>`);
            if (!ok) return;
            try {
                const { rosterColRef } = getSimRefs();
                const batch = writeBatch(db);
                checks.forEach(ch => batch.delete(doc(rosterColRef, ch.value)));
                await batch.commit();
                toast('Selected students removed.', 'success');
                await loadExistingRoster();
            } catch (err) {
                console.error('removeSelectedStudents error', err);
                toast(`Failed to remove: ${err.message}`, 'error');
            }
        }

        async function clearAllRoster() {
            const ok = await confirmAction('Clear entire roster?', '<p>This will remove <em>all</em> students from this class roster.</p>');
            if (!ok) return;
            try {
                const { rosterColRef } = getSimRefs();
                const snapshot = await getDocs(rosterColRef);
                if (snapshot.empty) { toast('Roster already empty.', 'info'); return; }
                let processed = 0;
                const docs = snapshot.docs;
                while (processed < docs.length) {
                    const chunk = docs.slice(processed, processed + 400);
                    const batch = writeBatch(db);
                    chunk.forEach(d => batch.delete(d.ref));
                    await batch.commit();
                    processed += chunk.length;
                }
                toast('Roster cleared.', 'success');
                await loadExistingRoster();
            } catch (err) {
                console.error('clearAllRoster error', err);
                toast(`Failed to clear roster: ${err.message}`, 'error');
            }
        }

        async function startSimulationDirectly() {
            try {
                const period = (reqEl('classPeriodSelect').value || '').trim();
                if (!period) { toast('Select a class period to start.', 'warning'); return; }
                
                const { simRef, rosterColRef, playersColRef, countryDataColRef } = getSimRefs();
                
                const rosterSnap = await getDocs(query(rosterColRef, where('period', '==', period)));
                
                if (rosterSnap.empty) {
                    toast('No students found in this period.', 'warning');
                    return;
                }
                
                const batch = writeBatch(db);
                
                rosterSnap.forEach(docSnap => {
                    const studentData = docSnap.data();
                    const email = docSnap.id;
                    const country = studentData.country;
                    
                    const playerRef = doc(playersColRef, email);
                    batch.set(playerRef, {
                        email: email,
                        displayName: email.split('@')[0],
                        country: country,
                        isTeacher: false,
                        needsBudgetInitialization: true,  // NEW FLAG
                        pnp: 100,
                        income: BASE_INCOME,
                        army: 0,
                        navy: 0,
                        colonies: [],
                        colonialPlans: [],
                        alliances: {},
                        militaryBudgetPercentage: 25,
                        domesticSpending: { healthcare: 20, education: 20, infrastructure: 20 },
                        happinessIndex: 100,
                        activeEvents: [],
                        militarySpendingThisRound: 0,
                        role: null,
                        roles: [],
                        hasSignedIn: false
                    }, { merge: true });
                    
                    const countryRef = doc(countryDataColRef, country);
                    batch.set(countryRef, {
                        pnp: 100,
                        roleAssignments: {},
                        alliances: {}
                    }, { merge: true });
                });
                
                batch.set(simRef, {
                    currentPeriod: period,
                    round: 1,
                    phase: 'waiting',
                    timerStartedAt: null,
                    timerDurationMinutes: null,
                    timerEnds: null
                }, { merge: true });
                
                await batch.commit();
                
                // NEW: Auto-initialize budgets after creating players
                toast('Initializing player budgets...', 'info');
                await initializeBudgetsForCurrentPeriod();
                
                toast(`Simulation started for Period ${period}. ${rosterSnap.size} students initialized.`, 'success');
                
                document.getElementById('rosterScreen').classList.add('hidden');
                document.getElementById('gameContainer').classList.remove('hidden');
                document.getElementById('teacherPanel').classList.remove('hidden');
                reqEl('displayClassCode').textContent = currentClassCode;
                reqEl('displayPlayerName').textContent = user?.displayName || user?.email || 'Teacher';
                
                setupFirestoreListeners();
                
            } catch (err) {
                console.error('startSimulationDirectly error', err);
                toast(`Failed to start: ${err.message}`, 'error');
            }
        }

        // =============== Teacher Controls ===============
        // Utility: batch iterate a collection and run a mutator over docs
        async function forEachDocInBatches(colRef, handler, batchSize = 400) {

        // =============== Domestic Spending & Flag ===============
        function getMyPlayer() {
            return localPlayersState ? localPlayersState[userId] : null;
        }

        function readDomesticSliders() {
            const healthcare = Number(reqEl('healthcareSlider').value || 0);
            const education = Number(reqEl('educationSlider').value || 0);
            const infrastructure = Number(reqEl('infrastructureSlider').value || 0);
            return { healthcare, education, infrastructure };
        }

        function updateDomesticUIFromSliders() {
            const me = getMyPlayer();
            const { healthcare, education, infrastructure } = readDomesticSliders();
            const totalDomesticPct = healthcare + education + infrastructure;
            const milPct = Number((qs('#militaryBudgetSlider')?.value) || 0);
            const totalBudget = Number(me?.dollars || 0);

            // Update percent labels
            reqEl('healthcarePercent').textContent = `${healthcare}%`;
            reqEl('educationPercent').textContent = `${education}%`;
            reqEl('infrastructurePercent').textContent = `${infrastructure}%`;

            // Compute $ values
            const hc$ = Math.round(totalBudget * healthcare / 100);
            const ed$ = Math.round(totalBudget * education / 100);
            const inf$ = Math.round(totalBudget * infrastructure / 100);
            reqEl('healthcareDollars').textContent = `($${hc$.toLocaleString()})`;
            reqEl('educationDollars').textContent = `($${ed$.toLocaleString()})`;
            reqEl('infrastructureDollars').textContent = `($${inf$.toLocaleString()})`;

            // Warnings
            const warnEl = reqEl('domesticWarnings');
            warnEl.innerHTML = '';
            const pushWarn = (msg) => warnEl.insertAdjacentHTML('beforeend', `<div class="text-sm text-red-700 bg-red-50 border border-red-200 rounded-md p-2">${msg}</div>`);

            if (totalDomesticPct > 100) pushWarn('Domestic allocations exceed 100%. Reduce sliders.');
            const totalAll = totalDomesticPct + milPct;
            if (totalAll > 100) pushWarn(`Domestic (${totalDomesticPct}%) + Military (${milPct}%) = ${totalAll}% (>100%). Reduce allocations.`);

            // Enable/disable Save button when invalid
            const saveBtn = qs('#ministerCardTemplate button.btn-success');
            if (saveBtn) saveBtn.disabled = (totalDomesticPct > 100 || totalAll > 100);
        }

        window.updateDomesticSpending = function() {
            try { updateDomesticUIFromSliders(); } catch (e) { console.warn(e); }
        }

        window.saveDomesticBudget = async function() {
            try {
                const me = getMyPlayer();
                if (!me) { toast('Player not ready yet.', 'warning'); return; }
                const { playerRef } = getSimRefs();
                const { healthcare, education, infrastructure } = readDomesticSliders();
                const milPct = Number((qs('#militaryBudgetSlider')?.value) || 0);
                const totalDomesticPct = healthcare + education + infrastructure;
                const totalAll = totalDomesticPct + milPct;
                if (totalDomesticPct > 100 || totalAll > 100) {
                    toast('Adjust sliders so Domestic + Military ≤ 100%.', 'warning');
                    return;
                }
                // Simple happiness heuristic
                let happinessIndex = Number(me.happinessIndex ?? 100);
                const target = 60 + healthcare * 0.3 + education * 0.25 + infrastructure * 0.15 - Math.max(0, totalAll - 100) * 0.5;
                happinessIndex = Math.max(0, Math.min(100, Math.round(target)));

                await updateDoc(playerRef(userId), {
                    domesticSpending: { healthcare, education, infrastructure },
                    happinessIndex
                });

                // Reflect in UI
                const topH = qs('#happinessTopDisplay');
                const bar = qs('#happinessBar');
                if (topH) topH.textContent = String(happinessIndex);
                if (bar) bar.style.width = `${happinessIndex}%`;

                toast('Domestic budget saved.', 'success');
            } catch (err) {
                console.error('saveDomesticBudget error', err);
                toast(`Failed to save budget: ${err.message}`, 'error');
            }
        }

        window.uploadFlag = async function() {
            try {
                const me = getMyPlayer();
                if (!me) { toast('Player not ready yet.', 'warning'); return; }
                const country = me.country || myCountryName;
                if (!country) { toast('No country detected for this player.', 'warning'); return; }
                const fileInput = reqEl('flagUploader');
                const file = fileInput.files && fileInput.files[0];
                if (!file) { toast('Choose an image first.', 'warning'); return; }
                if (file.size > 1_000_000) { toast('Image is larger than 1MB. Please select a smaller image.', 'warning'); return; }

                // Read file as data URL and upload to Firebase Storage
                const reader = new FileReader();
                const dataUrl = await new Promise((res, rej) => {
                    reader.onerror = () => rej(new Error('Failed to read image'));
                    reader.onload = () => res(reader.result);
                    reader.readAsDataURL(file);
                });

                const { basePath, countryRef } = getSimRefs();
                const path = `${basePath}/flags/${country}.jpg`;
                const storageRef = ref(storage, path);
                await uploadString(storageRef, dataUrl, 'data_url');
                const url = await getDownloadURL(storageRef);

                await setDoc(countryRef(country), { flagUrl: url }, { merge: true });

                // Update previews
                const prev = qs('#flagPreview');
                if (prev) prev.src = url;
                const banner = qs('#studentCountryBanner');
                if (banner) {
                    const emblem = qs('#bannerEmblem');
                    if (emblem) emblem.innerHTML = `<img src="${url}" alt="Flag" class="w-full h-full object-cover rounded-md">`;
                }

                toast('Flag uploaded.', 'success');
            } catch (err) {
                console.error('uploadFlag error', err);
                toast(`Flag upload failed: ${err.message}`, 'error');
            }
        }

        // Initialize domestic UI once sliders are present
        document.addEventListener('DOMContentLoaded', () => {
            ['healthcareSlider','educationSlider','infrastructureSlider'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.addEventListener('input', () => window.updateDomesticSpending());
            });
        });
            const snap = await getDocs(colRef);
            const docs = snap.docs;
            let i = 0;
            while (i < docs.length) {
                const chunk = docs.slice(i, i + batchSize);
                const batch = writeBatch(db);
                for (const d of chunk) { await handler(d, batch); }
                await batch.commit();
                i += chunk.length;
            }
            return docs.length;
        }

        // 7) Start Round: set timer + reset per-round spend
        window.startRound = async function() {
            try {
                const minutes = parseInt(reqEl('timerMinutes').value, 10) || 15;
                const { simRef, playersColRef } = getSimRefs();

                await updateDoc(simRef, {
                    phase: 'active',
                    timerStartedAt: serverTimestamp(),
                    timerDurationMinutes: minutes,
                    timerEnds: new Date(Date.now() + minutes * 60000)
                });

                // Reset per-round spending counters for all non-teacher players
                await forEachDocInBatches(playersColRef, async (d, batch) => {
                    const data = d.data();
                    if (!data.isTeacher) {
                        batch.update(d.ref, { militarySpendingThisRound: 0 });
                    }
                });
                toast('Round started. Timer running.', 'success');
            } catch (err) {
                console.error('startRound error', err);
                toast(`Failed to start round: ${err.message}`, 'error');
            }
        }

        // 8) End Round: move to review/locked state
        window.endRound = async function() {
            try {
                const { simRef } = getSimRefs();
                await updateDoc(simRef, { phase: 'review' });
                toast('Round ended. Actions locked for review.', 'info');
            } catch (err) {
                console.error('endRound error', err);
                toast(`Failed to end round: ${err.message}`, 'error');
            }
        }

        // Helper: add an entry to a player's log collection
        async function appendPlayerLog(playerId, message) {
            try {
                const { basePath } = getSimRefs();
                const logsCol = collection(db, `${basePath}/players/${playerId}/log`);
                await addDoc(logsCol, { message, ts: serverTimestamp() });
            } catch (e) {
                console.warn('appendPlayerLog warning:', e?.message);
            }
        }

        // 9) Resolve Colonial Chance (minimal working version)
        // Expects each player doc may have: colonialPlans: [{ territoryKey, invest }]
        window.resolveColonialChance = async function() {
            try {
                const { playersColRef } = getSimRefs();
                const snap = await getDocs(playersColRef);
                let resolutions = 0;
                const batch = writeBatch(db);
                snap.forEach(d => {
                    const p = d.data();
                    const plans = Array.isArray(p.colonialPlans) ? p.colonialPlans : [];
                    if (!plans.length) return;

                    let dollars = Number(p.dollars || 0);
                    let colonies = Array.isArray(p.colonies) ? p.colonies.slice() : [];

                    for (const plan of plans) {
                        const t = COLONIAL_TERRITORIES[plan.territoryKey];
                        if (!t) continue;
                        const cost = Number(t.cost || 0);
                        if (dollars < cost) { continue; }
                        dollars -= cost;
                        // Simple 50/50 success chance; you can tune per territory later
                        const success = Math.random() < 0.5;
                        if (success) {
                            colonies.push({ key: plan.territoryKey, name: t.name, income: t.income, acquiredAt: Date.now() });
                        }
                        resolutions++;
                    }
                    // Clear plans and write back updated money/colonies
                    batch.update(d.ref, { dollars, colonies, colonialPlans: [] });
                });
                if (resolutions === 0) { toast('No colonial investments to resolve.', 'info'); return; }
                await batch.commit();
                toast(`Colonial outcomes resolved for ${resolutions} plan${resolutions!==1?'s':''}.`, 'success');
            } catch (err) {
                console.error('resolveColonialChance error', err);
                toast(`Failed to resolve colonial chance: ${err.message}`, 'error');
            }
        }

        // 10) Check Alliances for conflicts (advisory)
        window.checkAlliances = async function() {
            try {
                const { countryDataColRef } = getSimRefs();
                const cSnap = await getDocs(countryDataColRef);
                if (cSnap.empty) { toast('No country data to check.', 'info'); return; }
                let warnings = 0;
                cSnap.forEach(cd => {
                    const country = cd.id;
                    const allies = Object.keys(cd.data().alliances || {});
                    const restricted = ALLIANCE_RESTRICTIONS[country] || [];
                    for (const a of allies) {
                        if (restricted.includes(a)) warnings++;
                    }
                });
                if (warnings > 0) {
                    toast(`Alliance check found ${warnings} potential violation${warnings!==1?'s':''}.`, 'warning');
                } else {
                    toast('Alliances look valid.', 'success');
                }
            } catch (err) {
                console.error('checkAlliances error', err);
                toast(`Failed to check alliances: ${err.message}`, 'error');
            }
        }

        // Helper: compute per-round income: base + colony incomes, modified by domestic spending
        function computeIncomeForPlayer(p) {
            const base = Number(BASE_INCOME || 25);

            // Colony income
            const colonies = Array.isArray(p.colonies) ? p.colonies : [];
            const colonyIncome = colonies.reduce((s, c) => s + Number(c.income || 0), 0);

            // Domestic spending modifiers (match endRound heuristics)
            const spending = p.domesticSpending || { healthcare: 20, education: 20, infrastructure: 20 };
            const total = (Number(spending.healthcare) || 0) + (Number(spending.education) || 0) + (Number(spending.infrastructure) || 0);

            let modifier = 1.0;
            if (total >= 75) modifier = 1.15;
            else if (total >= 60) modifier = 1.05;
            else if (total >= 45) modifier = 1.0;
            else if (total >= 30) modifier = 0.85;
            else if (total >= 15) modifier = 0.65;
            else modifier = 0.4;

            // Final per-round income (base + colonies) adjusted by domestic spending
            return Math.floor((base + colonyIncome) * modifier);
        }

        // 11) Advance to Next Round: apply income, reset per-round fields
        window.nextRound = async function() {
            try {
                const { simRef, playersColRef } = getSimRefs();
                // Load current round
                const simSnap = await getDoc(simRef);
                const curRound = Number(simSnap.exists() ? (simSnap.data().round || 1) : 1);

                // Apply income + reset round fields
                await forEachDocInBatches(playersColRef, async (d, batch) => {
                    const p = d.data();
                    if (p.isTeacher) return;
                    const income = computeIncomeForPlayer(p);
                    const newDollars = Number(p.dollars || 0) + income * 1000; // scale into currency units
                    batch.update(d.ref, {
                        dollars: newDollars,
                        militarySpendingThisRound: 0
                    });
                });

                await updateDoc(simRef, { round: curRound + 1, phase: 'waiting', timerStartedAt: null, timerDurationMinutes: null, timerEnds: null });
                toast(`Advanced to Round ${curRound + 1}.`, 'success');
            } catch (err) {
                console.error('nextRound error', err);
                toast(`Failed to advance round: ${err.message}`, 'error');
            }
        }

        // 12) Export Results (PDF)
        window.exportResults = async function() {
            try {
                const { jsPDF } = window.jspdf;
                const docPdf = new jsPDF();
                const { playersColRef } = getSimRefs();
                const snap = await getDocs(playersColRef);
                const rows = [];
                snap.forEach(d => {
                    const p = d.data();
                    if (p.isTeacher) return;
                    rows.push([
                        p.country || '-',
                        p.displayName || p.email || d.id,
                        String(p.dollars ?? 0),
                        String(p.army || 0),
                        String(p.navy || 0),
                        (Array.isArray(p.colonies) ? p.colonies.length : 0)
                    ]);
                });
                rows.sort((a,b) => a[0].localeCompare(b[0]));
                docPdf.text('The North – Simulation Results', 14, 16);
                docPdf.autoTable({
                    head: [['Country','Player','$','Army','Navy','# Colonies']],
                    body: rows,
                    startY: 22,
                    styles: { fontSize: 10 }
                });
                docPdf.save('north_sim_results.pdf');
                toast('Exported PDF.', 'success');
            } catch (err) {
                console.error('exportResults error', err);
                toast(`Failed to export: ${err.message}`, 'error');
            }
        }

        // 13) Reset Game (soft reset)
        window.resetGame = async function() {
            const ok = await confirmAction('Reset full game?', '<p>This will reset round, phase, and player budgets/round-spend. War declarations will be cleared.</p>');
            if (!ok) return;
            try {
                const { simRef, playersColRef, warDeclarationsColRef } = getSimRefs();
                // Reset sim
                await setDoc(simRef, { round: 1, phase: 'waiting', timerStartedAt: null, timerDurationMinutes: null, timerEnds: null }, { merge: true });
                // Reset players (keep identities/roles)
                await forEachDocInBatches(playersColRef, async (d, batch) => {
                    const p = d.data();
                    if (p.isTeacher) return;
                    const startBudget = getDefaultStartingBudget(p.country) ?? 0;
                    batch.update(d.ref, {
                        dollars: startBudget,
                        army: 0,
                        navy: 0,
                        colonies: [],
                        colonialPlans: [],
                        militarySpendingThisRound: 0
                    });
                });
                // Clear war declarations
                const warSnap = await getDocs(warDeclarationsColRef);
                if (!warSnap.empty) {
                    const batch = writeBatch(db);
                    warSnap.forEach(w => batch.delete(w.ref));
                    await batch.commit();
                }
                toast('Game reset complete.', 'success');
            } catch (err) {
                console.error('resetGame error', err);
                toast(`Failed to reset: ${err.message}`, 'error');
            }
        }
        
        // Teacher initializes budgets for all players in current period
        window.initializeBudgetsForCurrentPeriod = async function() {
            if (!isTeacher) {
                toast('Only teachers can initialize budgets', 'error');
                return;
            }
            
            try {
                toast('Initializing player budgets...', 'info');
                
                // First, ensure game rules exist
                const gameRulesRef = doc(db, `apps/${APP_ID}/gameRules/budgets`);
                const rulesSnap = await getDoc(gameRulesRef);
                
                if (!rulesSnap.exists()) {
                    const shouldInit = await confirmAction(
                        'Initialize Game Rules?',
                        '<p>Game rules not found. Initialize them now?</p>'
                    );
                    
                    if (shouldInit) {
                        await initializeGameRules();
                    } else {
                        return;
                    }
                }
                
                // Get all players needing budget initialization
                const { playersColRef } = getSimRefs();
                const playersSnap = await getDocs(query(playersColRef, 
                    where('needsBudgetInitialization', '==', true)));
                
                if (playersSnap.empty) {
                    toast('No players need budget initialization', 'info');
                    return;
                }
                
                const batch = writeBatch(db);
                let count = 0;
                
                for (const playerDoc of playersSnap.docs) {
                    const playerData = playerDoc.data();
                    const country = playerData.country;
                    
                    if (!country) continue;
                    
                    const budget = await getStartingBudget(country);
                    
                    batch.update(playerDoc.ref, {
                        dollars: budget,
                        needsBudgetInitialization: false,
                        budgetInitializedAt: serverTimestamp()
                    });
                    
                    count++;
                }
                
                await batch.commit();
                
                toast(`Successfully initialized budgets for ${count} player(s)`, 'success');
                
            } catch (err) {
                console.error('initializeBudgetsForCurrentPeriod error:', err);
                toast(`Failed to initialize budgets: ${err.message}`, 'error');
            }
        };

        async function notifyApprovers(warId, warDeclaration) {
             const approverRoles = ['Secretary of State', 'Minister of Domestic Tranquility'];
             const countryPlayers = Object.values(localPlayersState).filter(p => p.country === myCountryName);
             
             for(const player of countryPlayers) {
                if(approverRoles.includes(player.role)) {
                    const player_id = Object.keys(localPlayersState).find(key => localPlayersState[key] === player);
                    const notifCol = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${player_id}/notifications`);
                    await addDoc(notifCol, {
                        type: 'war_approval_request',
                        from: myCountryName,
                        message: `Your approval is required for a declaration of war.`,
                        warId: warId,
                        timestamp: serverTimestamp()
                    });
                }
             }
        }
        
        async function signInWithGoogle() {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                console.error("Google Sign-In failed:", error);
                document.getElementById('loginError').textContent = `Sign-in failed: ${error.message}`;
            }
        }

        async function joinSimulation() {
            if (!user || !user.email) {
                showError('classCodeError', 'Authentication error. Please sign in again.');
                return;
            }

            const classCode = document.getElementById('classCodeInput').value.trim().toUpperCase();
            if (!classCode) {
                showError('classCodeError', 'Please enter a class code.');
                return;
            }
            currentClassCode = classCode;
            const joinBtn = document.getElementById('joinClassBtn');
            joinBtn.disabled = true;
            joinBtn.textContent = 'Verifying...';

            try {
                const teacherRef = doc(db, `apps/${APP_ID}/teachers`, user.email);
                const simRef = doc(db, `apps/${APP_ID}/simulations`, classCode);
                const rosterRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/roster`, user.email);
                
                const [teacherSnap, simSnap, rosterSnap] = await Promise.all([getDoc(teacherRef), getDoc(simRef), getDoc(rosterRef)]);

                if (teacherSnap.exists()) {
                    await setupNewTeacher(simSnap, simRef);
                } else if (rosterSnap.exists()) {
                    await setupNewStudent(simSnap, rosterSnap);
                    document.getElementById('classCodeScreen').classList.add('hidden');
                    document.getElementById('gameContainer').classList.remove('hidden');
                    setupFirestoreListeners();
                } else {
                    showError('classCodeError', 'You are not on the roster for this class.');
                }
            } catch (error) {
                console.error("Error joining simulation:", error);
                showError('classCodeError', `An error occurred: ${error.message}`);
            } finally {
                joinBtn.disabled = false;
                joinBtn.textContent = 'Join / Create Simulation';
            }
        }

        async function setupNewTeacher(simSnap, simRef) {
            if (!isTeacherEmail(user.email)) {
                showError('classCodeError', 'Teachers must use their dexterschools.org email without a period (e.g., jsmith@dexterschools.org)');
                return;
            }

            isTeacher = true;
            myCountryName = 'Teacher';
            
            // NEW: Initialize game rules
            await initializeGameRules();
            
            if (!simSnap.exists()) {
                await setDoc(simRef, {
                    teacherId: user.uid,
                    teacherEmail: user.email,
                    round: 1,
                    phase: 'waiting',
                    timerEnds: null,
                });
            }
            
            const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, userId);
            await setDoc(playerRef, { name: user.displayName, isTeacher: true }, { merge: true});

            document.getElementById('classCodeScreen').classList.add('hidden');
            document.getElementById('rosterScreen').classList.remove('hidden');
            document.getElementById('rosterClassCode').textContent = currentClassCode;
            loadExistingRoster();
        }

        async function setupNewStudent(simSnap, rosterSnap) {
            // Validate that this is a student email format
            if (!STUDENT_EMAIL_REGEX.test(user.email)) {
                showError('classCodeError', 'Students must use their dexterschools.org email in firstname.lastname format');
                return;
            }

            isTeacher = false;
            if (!simSnap.exists()) {
                showError('classCodeError', 'This class code does not exist.');
                throw new Error('Simulation not found');
            }
            myCountryName = rosterSnap.data().country;

            const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, user.email);
            
            // CHANGED: Don't set dollars yet - teacher will initialize
            await setDoc(playerRef, {
                displayName: user.displayName || user.email,
                country: myCountryName,
                hasSignedIn: true,
                lastSignInAt: serverTimestamp(),
                needsBudgetInitialization: true,  // NEW FLAG
                income: BASE_INCOME,
                army: 0,
                navy: 0,
                colonies: [],
                colonialPlans: [],
                alliances: {},
                militaryBudgetPercentage: 25,
                domesticSpending: { healthcare: 20, education: 20, infrastructure: 20 },
                happinessIndex: 100,
                activeEvents: [],
                militarySpendingThisRound: 0,
                role: null,
                roles: []
            }, { merge: true });

            // Wait for player data to sync
            const playerId = user.email;
            const start = Date.now();
            while (Date.now() - start < 5000) {
                if (localPlayersState && localPlayersState[playerId]) break;
                await new Promise(r => setTimeout(r, 200));
            }

            // The setupFirestoreListeners will handle showing the interface once data arrives
        }
        
        function cleanupListeners() {
            if (gameStateUnsubscribe) gameStateUnsubscribe();
            if (playersUnsubscribe) playersUnsubscribe();
            if (logUnsubscribe) logUnsubscribe();
            if (notificationUnsubscribe) notificationUnsubscribe();
            if (countryDataUnsubscribe) countryDataUnsubscribe();
            if (warDeclarationsUnsubscribe) warDeclarationsUnsubscribe();
        }

        function setupFirestoreListeners() {
            cleanupListeners();
            
            const gameDocRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}`);
            gameStateUnsubscribe = onSnapshot(gameDocRef, (doc) => {
                if (doc.exists()) {
                    localGameState = doc.data();
                    updateGameUI();
                    maybeTriggerRoleAssignment();
                }
            });

            const playersColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`);
            let playersFirstLoad = true;
            playersUnsubscribe = onSnapshot(playersColRef, (snapshot) => {
                localPlayersState = {};
                snapshot.forEach(doc => { localPlayersState[doc.id] = doc.data(); });
                updateAllPlayersUI();
                maybeTriggerRoleAssignment();
                
                // If this is a student, refresh their tabs whenever their player data changes
                if (!isTeacher && localPlayersState[userId]) {
                    setupStudentTabs();
                }
                
                // after initial players load, ensure domestic UI is synced immediately
                if (playersFirstLoad) {
                    playersFirstLoad = false;
                    // Only enable controls if the current player is in a valid ready state
                    if (typeof enablePlayerControlsIfReady === 'function') {
                        enablePlayerControlsIfReady();
                    }
                    // call immediate domestic updater so sliders/values show right away
                    if (typeof updateDomesticSpendingImmediate === 'function') {
                        updateDomesticSpendingImmediate();
                    }
                }
            });

            const countryDataColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/countryData`);
            countryDataUnsubscribe = onSnapshot(countryDataColRef, (snapshot) => {
                localCountryData = {};
                snapshot.forEach(doc => { localCountryData[doc.id] = doc.data(); });
                updateAllPlayersUI(); 
                try { renderTreasuryLockState(); } catch(_) {}
                maybeTriggerRoleAssignment();
            });
            
            const warDeclarationsColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/warDeclarations`);
            warDeclarationsUnsubscribe = onSnapshot(warDeclarationsColRef, (snapshot) => {
                localWarDeclarations = {};
                snapshot.forEach(doc => { localWarDeclarations[doc.id] = doc.data(); });
                updateAllPlayersUI();
            });

            // Monitor wars for deadline expiration and auto-progress if appropriate
            try {
                const warsWatcher = onSnapshot(warDeclarationsColRef, async (snapshot) => {
                    snapshot.forEach(async (d) => {
                        try {
                            const war = d.data();
                            if (!war) return;
                            if (war.status === 'mobilizing' && war.mobilizationDeadline) {
                                // Support Firestore Timestamp or Date-like
                                const deadline = (typeof war.mobilizationDeadline.toDate === 'function')
                                    ? war.mobilizationDeadline.toDate()
                                    : new Date(war.mobilizationDeadline);
                                if (Date.now() > deadline.getTime()) {
                                    console.log(`War ${d.id} mobilization deadline passed`);
                                    // If teacher, automatically progress to in_battle and notify
                                    if (isTeacher) {
                                        try {
                                            await handleMobilizationDeadline(d.id, war);
                                            toast(`War ${d.id} mobilization deadline reached — progressed to battle.`, 'info');
                                        } catch (e) {
                                            console.error('Error handling mobilization deadline for', d.id, e);
                                        }
                                    } else {
                                        // Non-teachers get a quiet console notice; teacher must act
                                        console.debug(`Mobilization deadline passed for war ${d.id}; awaiting teacher action.`);
                                    }
                                }
                            }
                        } catch (e) { console.warn('warsWatcher change handler error', e); }
                    });
                });
                // add to cleanup so listener can be removed when leaving
                const origCleanup = cleanupListeners;
                cleanupListeners = function() {
                    try { warsWatcher(); } catch (e) {}
                    try { origCleanup(); } catch (e) {}
                };
            } catch (e) {
                console.warn('Failed to attach warsWatcher', e);
            }


            if (!isTeacher) {
                const logColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${userId}/log`);
                logUnsubscribe = onSnapshot(query(logColRef), (snapshot) => {
                    const logEntries = snapshot.docs.map(d => d.data());
                    updateEventLog(logEntries);
                });
                
                const notificationColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${userId}/notifications`);
                notificationUnsubscribe = onSnapshot(query(notificationColRef), (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            const data = change.doc.data();
                            // If mobilization is required, show a notification that allows the player
                            // to open the mobilization UI explicitly rather than auto-opening it.
                            if (data && data.type === 'mobilization_required') {
                                try {
                                    showMobilizationNotification(data.warId, change.doc.id);
                                } catch (e) {
                                    console.error('Failed to show mobilization notification:', e);
                                    showStudentNotificationModal(data, change.doc.id);
                                }
                            } else {
                                showStudentNotificationModal(data, change.doc.id);
                            }
                        }
                    });
                });
            }
        }
        
        

        async function updateWarDeclarationUI() {
            const myRoles = getMyRoles();
            const warInterface = document.getElementById('warDeclarationInterface');
            const round = localGameState.round || 1;

            if (warInterface) {
                if (myRoles.includes('Secretary of War') && round >= 4) {
                    warInterface.classList.remove('hidden');
                } else {
                    warInterface.classList.add('hidden');
                }
            }

            if (myRoles.includes('Secretary of State') || myRoles.includes('Minister of Domestic Tranquility')) {
                if (typeof loadWarApprovals === 'function') {
                    try { await loadWarApprovals(); } catch (err) { console.error('loadWarApprovals failed:', err); }
                }
            }

            if (myRoles.includes('Secretary of War')) {
                if (typeof loadPendingWarDeclarations === 'function') {
                    try { await loadPendingWarDeclarations(); } catch (err) { console.error('loadPendingWarDeclarations failed:', err); }
                }
            }
        }

        window.switchTab = function(targetId) {
            document.querySelectorAll('#roleTabs .tab-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.target === targetId);
            });
            document.querySelectorAll('#roleTabContent .tab-panel').forEach(panel => {
                panel.classList.toggle('active', panel.id === targetId);
            });
            updateWarDeclarationUI();
        }

        async function createLog(message, forUserId = userId) {
            if (isTeacher && !forUserId) return; // Teachers don't have personal logs
            const finalUserId = isTeacher ? forUserId : userId;
            const logColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${finalUserId}/log`);
            await addDoc(logColRef, { message, timestamp: serverTimestamp() });
        }
        
        function updateGameUI() {
            const { round, phase, timerEnds } = localGameState;
            document.getElementById('currentRound').textContent = round || 1;
            const phaseIndicator = document.getElementById('phaseIndicator');
            const phaseTextEl = document.getElementById('phaseText');
            let phaseDisplay, phaseColor;
            switch (phase) {
                case 'active': phaseDisplay = `Active - ${getTimerDisplay(timerEnds)}`; phaseColor = 'bg-green-600'; break;
                case 'review': phaseDisplay = 'Review Phase'; phaseColor = 'bg-yellow-500'; break;
                default: phaseDisplay = 'Waiting for Teacher'; phaseColor = 'bg-gray-500';
            }
            phaseTextEl.textContent = phaseDisplay;
            phaseIndicator.className = `text-center text-white rounded-full px-6 py-2 ${phaseColor}`;

            if (isTeacher) {
                document.getElementById('teacherPanel').classList.remove('hidden');
                document.getElementById('studentRoleInterface').classList.add('hidden');
                document.getElementById('startRoundBtn').disabled = phase === 'active';
                document.getElementById('endRoundBtn').disabled = phase !== 'active';
                document.getElementById('colonialChanceBtn').disabled = phase !== 'review';
                document.getElementById('checkAlliancesBtn').disabled = phase !== 'review';
                document.getElementById('nextRoundBtn').disabled = phase !== 'review';
            }
            // Keep student UI (e.g., war button visibility) in sync when only the game doc changes
            if (!isTeacher) {
                updateWarDeclarationUI();
            }
        }
        
        let countdownInterval;
        function getTimerDisplay(timerEnds) {
            // Ensure only one interval runs
            clearInterval(countdownInterval);

            const toMillis = (t) => {
                if (!t) return null;
                if (typeof t.toDate === 'function') return t.toDate().getTime(); // Firestore Timestamp
                if (t instanceof Date) return t.getTime();                        // JS Date
                const parsed = new Date(t);
                return isNaN(parsed.getTime()) ? null : parsed.getTime();         // string/number
            };

            // Prefer server-derived timerStartedAt + duration from game doc to avoid client clock skew
            const endTime = (() => {
                try {
                    if (localGameState?.timerStartedAt && localGameState?.timerDurationMinutes) {
                        const startMs = (typeof localGameState.timerStartedAt.toDate === 'function')
                            ? localGameState.timerStartedAt.toDate().getTime()
                            : new Date(localGameState.timerStartedAt).getTime();
                        return startMs + (Number(localGameState.timerDurationMinutes) * 60000);
                    }
                } catch (e) {
                    // ignore and fallback
                }
                // fallback to the original timerEnds value (backwards compatibility)
                if (!timerEnds) return null;
                return toMillis(timerEnds);
            })();

            if (!endTime || Number.isNaN(endTime)) return '00:00';

            const formatDisplay = (msLeft) => {
                const minutes = Math.floor(msLeft / 60000);
                const seconds = Math.floor((msLeft % 60000) / 1000);
                return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            };

            const update = () => {
                const now = Date.now();
                const timeLeft = Math.max(0, endTime - now);
                const display = formatDisplay(timeLeft);

                const phaseTextEl = document.getElementById('phaseText');
                if (phaseTextEl) {
                    // Always set the full string so the UI never shows a truncated value
                    // When the phase isn't active we still update the display part so it stays in sync
                    if (localGameState.phase === 'active') {
                        phaseTextEl.textContent = `Active - ${display}`;
                    } else {
                        phaseTextEl.textContent = display;
                    }
                }

                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                }
            };

            // Run one immediate update and then start the interval
            update();
            countdownInterval = setInterval(update, 1000);

            // Return an initial MM:SS string so callers (updateGameUI) can build their label immediately
            const initialDisplay = formatDisplay(Math.max(0, endTime - Date.now()));
            return initialDisplay;
        }

        function updateAllPlayersUI() {
            const myData = localPlayersState[userId];
            // Add this inside updateAllPlayersUI() for students
            if (!isTeacher && myCountryName) {
                const banner = document.getElementById('studentCountryBanner');
                const theme = COUNTRY_THEMES[myCountryName];
                if (banner && theme) {
                    banner.style.backgroundImage = `url('${theme.banner}')`;
                    banner.classList.remove('hidden');
                    document.getElementById('bannerCountryName').textContent = myCountryName;
                    document.getElementById('bannerEmblem').innerHTML = theme.emblem;
                }
                
                document.getElementById('displayPlayerName').textContent = user.displayName || user.email;
                document.getElementById('displayClassCode').textContent = currentClassCode;
                // Enable student controls as soon as player data is present
                if (myData) enableStudentControls();
            }
            if (myData && !isTeacher) {
                document.getElementById('countryBudget').textContent = (myData.dollars || 0).toLocaleString();
                document.getElementById('roundIncome').textContent = (myData.income || 0).toLocaleString();
                document.getElementById('armyUnits').textContent = myData.army || 0;
                document.getElementById('navyUnits').textContent = myData.navy || 0;
                document.getElementById('happinessTopDisplay').textContent = myData.happinessIndex || 100;

                // Initialize sliders from database
                const domesticSpending = myData.domesticSpending || { healthcare: 20, education: 20, infrastructure: 20 };
                document.getElementById('healthcareSlider').value = domesticSpending.healthcare;
                document.getElementById('educationSlider').value = domesticSpending.education;
                document.getElementById('infrastructureSlider').value = domesticSpending.infrastructure;

                // Display active events
                const activeEvents = myData.activeEvents || [];
                const eventsListEl = document.getElementById('activeEventsList');
                if (eventsListEl) {
                    if (activeEvents.length > 0) {
                        eventsListEl.innerHTML = activeEvents.map(evt =>
                            `<div class="bg-yellow-50 border border-yellow-200 rounded-lg p-3 text-sm text-yellow-800">${evt}</div>`
                        ).join('');
                    } else {
                        eventsListEl.innerHTML = '<p class="text-gray-500">No active events.</p>';
                    }
                }
                
                // Update military budget displays
                const militaryBudget = Math.floor((myData.dollars || 0) * ((myData.militaryBudgetPercentage || 25) / 100));
                const remainingBudget = militaryBudget - (myData.militarySpendingThisRound || 0);

                ['main', 'war'].forEach(context => {
                    const totalEl = document.getElementById(`warTotalBudget-${context}`);
                    const remainingEl = document.getElementById(`warRemainingBudget-${context}`);
                    if (totalEl) totalEl.textContent = `$${militaryBudget.toLocaleString()}`;
                    if (remainingEl) remainingEl.textContent = `$${remainingBudget.toLocaleString()}`;
                });
                
                const treasuryTotal = document.getElementById('treasuryTotalBudget');
                const treasuryMilitary = document.getElementById('treasuryMilitaryBudget');
                if (treasuryTotal) treasuryTotal.textContent = `$${(myData.dollars || 0).toLocaleString()}`;
                if (treasuryMilitary) treasuryMilitary.textContent = `$${militaryBudget.toLocaleString()}`;

                // Update slider
                const slider = document.getElementById('militaryBudgetSlider');
                if (slider) slider.value = myData.militaryBudgetPercentage || 25;

                // Update UI based on slider values
                updateDomesticSpending();
            }
            updateWarDeclarationUI();
            updateLeaderboard();
                const colonialPlanningUI = document.getElementById('colonialPlanning');
            if(colonialPlanningUI) populateColonialOptions();

            // Update colonies display in the Treasury card (students only)
            if (!isTeacher && myCountryName) {
                try { window.renderMyColonies(); } catch(e) { /* ignore if not ready */ }
            }

            // Reflect treasury lock state from country data
            try { renderTreasuryLockState(); } catch(e) { /* ignore if not available yet */ }
        }

        // Render the current player's owned colonies into #myColoniesDisplay (exposed on window)
        window.renderMyColonies = function() {
            const me = localPlayersState ? localPlayersState[userId] : null;
            if (!me) return;

            const container = document.getElementById('myColoniesDisplay');
            if (!container) return;

            const colonies = Array.isArray(me.colonies) ? me.colonies : [];
            if (colonies.length === 0) {
                container.innerHTML = '<p class="text-gray-500">No colonies yet.</p>';
                return;
            }

            container.innerHTML = colonies.map(col => `
                <div class="bg-green-50 border border-green-200 rounded-lg p-3">
                    <div class="font-semibold text-green-800">${col.name}</div>
                    <div class="text-sm text-green-700">Income: +${col.income} per round</div>
                </div>
            `).join('');
        };
        
        function updateEventLog(entries) {
            const logEl = document.getElementById('eventLog');
            if (!entries || entries.length === 0) {
                logEl.innerHTML = `<p class="text-gray-500">No events yet.</p>`;
                return;
            }
            logEl.innerHTML = entries
                .sort((a,b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0))
                .map(entry => `<div class="p-2 rounded bg-gray-50">${entry.message}</div>`)
                .join('');
        }

        function calculateTotalPnp(player) {
            const armyPnp = (player.army || 0) * 750;
            const navyPnp = (player.navy || 0) * 1000;
            const coloniesPnp = Object.values(player.colonies || {}).reduce((sum, colony) => sum + (colony.cost || 0), 0);
            return (player.pnp || 0) + armyPnp + navyPnp + coloniesPnp;
        }

        // Make available globally for late-bound callers (eg. finalizeBattleResults)
        window.calculateTotalPnp = calculateTotalPnp;

        function updateLeaderboard() {
            const playersArray = Object.values(localPlayersState).filter(p => !p.isTeacher);
            playersArray.forEach(p => {
                p.basePnp = (localCountryData[p.country]?.pnp || 100) + (p.pnp - 100);
                const armyPnp = (p.army || 0) * 750;
                const navyPnp = (p.navy || 0) * 1000;
                const coloniesPnp = Object.values(p.colonies || {}).reduce((sum, colony) => sum + (colony.cost || 0), 0);
                p.assetScore = armyPnp + navyPnp + coloniesPnp;
                p.totalScore = p.basePnp + p.assetScore;
            });
            playersArray.sort((a, b) => b.totalScore - a.totalScore);
            const listEl = document.getElementById('leaderboardList');
            listEl.innerHTML = playersArray.map((p, index) => {
                const isMe = p.country === myCountryName;
                const bgColor = isMe ? 'bg-indigo-100' : 'bg-gray-50';
                const countryData = localCountryData[p.country] || {};
                const flagUrl = countryData.flagUrl;
                const emblem = COUNTRY_THEMES[p.country]?.emblem || `<div class="w-8 h-6 bg-gray-300 rounded-sm"></div>`;
                const flagElement = flagUrl 
                    ? `<img src="${flagUrl}" alt="${p.country} flag" class="w-8 h-6 object-cover rounded-sm shadow-sm">` 
                    : `<div class="w-8 h-6 flex items-center justify-center">${emblem}</div>`;

                return `
                    <div class="p-3 rounded-lg ${bgColor} flex justify-between items-center">
                        <div class="flex items-center flex-grow">
                            ${flagElement}
                            <div class="ml-3">
                                <span class="font-bold text-gray-800">${index+1}. ${p.country}</span>
                                <span class="text-sm text-gray-500 ml-2">(${p.name})</span>
                            </div>
                        </div>
                        <div class="text-right">
                             <span class="font-bold text-indigo-700">${p.totalScore.toLocaleString()} PNP</span>
                             <div class="text-xs text-gray-500">Base: ${p.basePnp.toLocaleString()} + Assets: ${p.assetScore.toLocaleString()}</div>
                        </div>
                    </div>`;
            }).join('');
        }
        
        function populateColonialOptions() {
            const container = document.getElementById('colonialPlanning');
            if (!container) return;
            container.innerHTML = '';
            const myData = localPlayersState[userId] || {};
            const phase = localGameState.phase;

            for (const [key, territory] of Object.entries(COLONIAL_TERRITORIES)) {
                const isOwnedByAnyone = Object.values(localPlayersState).some(p => p.colonies && p.colonies[key]);
                const haveIPlanned = myData.colonialPlans && myData.colonialPlans[key];
                let buttonHtml;
                if(isOwnedByAnyone) {
                    const owner = Object.values(localPlayersState).find(p => p.colonies && p.colonies[key]);
                    buttonHtml = `<button class="btn btn-secondary w-full" disabled>Owned by ${owner.country}</button>`;
                } else if (haveIPlanned) {
                    buttonHtml = `<button class="btn btn-success w-full" disabled>Attempt Planned</button>`;
                } else {
                    buttonHtml = `<button class="btn btn-warning w-full" onclick="planColonization('${key}')" ${phase !== 'active' ? 'disabled' : ''}>Plan Attempt</button>`;
                }
                container.innerHTML += `
                    <div class="bg-gray-50 p-3 rounded-lg space-y-2">
                        <div class="font-bold">${territory.name}</div>
                        <div class="text-sm text-gray-600">Cost: ${territory.cost.toLocaleString()} $ | Income: ${territory.income} $</div>
                        ${buttonHtml}
                    </div>`;
            }
        }

        function updateMyAllianceUI(myAlliances) {
            const container = document.getElementById('myAlliances');
            if (!container) return;
            const allies = Object.keys(myAlliances).filter(id => myAlliances[id] === true);
            if(allies.length === 0) {
                container.innerHTML = `<h4 class="font-semibold mt-4">My Current Allies:</h4> <p class="text-gray-500">None</p>`;
            } else {
                const allyNames = allies.map(id => localPlayersState[id]?.country || '...').join(', ');
                container.innerHTML = `<h4 class="font-semibold mt-4">My Current Allies:</h4> <p class="text-green-700 font-semibold">${allyNames}</p>`;
            }
        }
        
        window.uploadFlag = async function() {
            const uploader = document.getElementById('flagUploader');
            const uploadBtn = document.getElementById('uploadFlagBtn');
            const file = uploader.files[0];

            if (!file) return showInfoModal("No File", "<p>Please select a file to upload.</p>");
            if (file.size > 1024 * 1024) return showInfoModal("File Too Large", "<p>Please select an image smaller than 1MB.</p>");

            uploadBtn.disabled = true;
            uploadBtn.textContent = 'Uploading...';

            try {
                const reader = new FileReader();
                reader.onload = async (event) => {
                    const base64String = event.target.result;
                    const storageRef = ref(storage, `apps/${APP_ID}/simulations/${currentClassCode}/flags/${myCountryName}.png`);
                    const uploadResult = await uploadString(storageRef, base64String, 'data_url');
                    const downloadURL = await getDownloadURL(uploadResult.ref);

                    const countryDocRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/countryData`, myCountryName);
                    await setDoc(countryDocRef, { flagUrl: downloadURL }, { merge: true });

                    showInfoModal("Success!", "<p>Your national flag has been updated.</p>");
                    await createLog(`Uploaded a new national flag.`);
                };
                reader.readAsDataURL(file);
            } catch(error) {
                console.error("Flag upload failed:", error);
                showInfoModal("Upload Failed", `<p>An error occurred: ${error.message}</p>`);
            } finally {
                uploadBtn.disabled = false;
                uploadBtn.textContent = 'Upload Flag';
            }
        }

        // ==== Domestic Policy System ====
        // Simple debounce helper
        function debounce(fn, wait) {
            let timer = null;
            return function(...args) {
                clearTimeout(timer);
                timer = setTimeout(() => fn.apply(this, args), wait);
            };
        }

        // Immediate updater used once after initial players load
        window.updateDomesticSpendingImmediate = function() {
            const myData = localPlayersState[userId];
            if (!myData) return;

            // Ensure controls are enabled only if player data is valid
            if (typeof enablePlayerControlsIfReady === 'function') enablePlayerControlsIfReady();

            const totalBudget = myData.dollars || 0;
            const healthcare = parseInt(document.getElementById('healthcareSlider')?.value || 20);
            const education = parseInt(document.getElementById('educationSlider')?.value || 20);
            const infrastructure = parseInt(document.getElementById('infrastructureSlider')?.value || 20);

            document.getElementById('healthcarePercent').textContent = `${healthcare}%`;
            document.getElementById('educationPercent').textContent = `${education}%`;
            document.getElementById('infrastructurePercent').textContent = `${infrastructure}%`;

            const healthcareDollars = Math.floor(totalBudget * healthcare / 100);
            const educationDollars = Math.floor(totalBudget * education / 100);
            const infrastructureDollars = Math.floor(totalBudget * infrastructure / 100);

            document.getElementById('healthcareDollars').textContent = `($${healthcareDollars.toLocaleString()})`;
            document.getElementById('educationDollars').textContent = `($${educationDollars.toLocaleString()})`;
            document.getElementById('infrastructureDollars').textContent = `($${infrastructureDollars.toLocaleString()})`;

            const warnings = [];
            const total = healthcare + education + infrastructure;
            if (total < 15) warnings.push({ type: 'danger', msg: '💀 CATASTROPHIC: Revolution imminent!' });
            else if (total < 30) warnings.push({ type: 'danger', msg: '🚨 CRISIS: Total domestic spending critically low!' });
            else if (total < 45) warnings.push({ type: 'warning', msg: '⚠️ WARNING: Unrest growing' });

            if (healthcare < 5) warnings.push({ type: 'danger', msg: '🏥 Healthcare system collapsed' });
            else if (healthcare < 10) warnings.push({ type: 'danger', msg: '🏥 Healthcare crisis imminent' });
            else if (healthcare < 15) warnings.push({ type: 'warning', msg: '🏥 Healthcare strained' });

            if (education < 5) warnings.push({ type: 'danger', msg: '📚 Education system destroyed' });
            else if (education < 10) warnings.push({ type: 'danger', msg: '📚 Education collapsing' });
            else if (education < 15) warnings.push({ type: 'warning', msg: '📚 Education declining' });

            if (infrastructure < 5) warnings.push({ type: 'danger', msg: '🛤️ Infrastructure failed' });
            else if (infrastructure < 10) warnings.push({ type: 'danger', msg: '🛤️ Infrastructure failing' });
            else if (infrastructure < 15) warnings.push({ type: 'warning', msg: '🛤️ Infrastructure deteriorating' });

            const warningsDiv = document.getElementById('domesticWarnings');
            if(warningsDiv) {
                if (warnings.length === 0) {
                    warningsDiv.innerHTML = '<div class="bg-green-50 border border-green-200 rounded-lg p-3 text-green-800">✓ Domestic spending adequate</div>';
                } else {
                    warningsDiv.innerHTML = warnings.map(w => 
                        `<div class="bg-${w.type === 'danger' ? 'red' : 'yellow'}-50 border border-${w.type === 'danger' ? 'red' : 'yellow'}-300 rounded-lg p-3 text-${w.type === 'danger' ? 'red' : 'yellow'}-800 font-semibold">${w.msg}</div>`
                    ).join('');
                }
            }

            const happiness = myData.happinessIndex || 100;
            document.getElementById('happinessDisplay').textContent = happiness;
            document.getElementById('happinessBar').style.width = `${Math.min(100, happiness)}%`;
        };

        // Enable controls for student interactions (called when student data is ready)
        function enableStudentControls() {
            // Delegate to readiness check so enabling only happens when player is in a valid state
            if (typeof enablePlayerControlsIfReady === 'function') enablePlayerControlsIfReady();
        }

        

        // Debounced version for UI event handlers
        window.updateDomesticSpending = debounce(function() {
            updateDomesticSpendingImmediate();
        }, 150);

        window.saveDomesticBudget = async function() {
            const healthcare = parseInt(document.getElementById('healthcareSlider').value);
            const education = parseInt(document.getElementById('educationSlider').value);
            const infrastructure = parseInt(document.getElementById('infrastructureSlider').value);
            
            const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, userId);
            try {
                await updateDoc(playerRef, {
                    "domesticSpending.healthcare": healthcare,
                    "domesticSpending.education": education,
                    "domesticSpending.infrastructure": infrastructure
                });
                showInfoModal("Success", "<p>Domestic budget allocations saved.</p>");
                createLog(`Updated domestic budget: Healthcare ${healthcare}%, Education ${education}%, Infrastructure ${infrastructure}%.`);
            } catch (error) {
                console.error("Failed to save domestic budget:", error);
                showInfoModal("Error", `<p>Could not save budget: ${error.message}</p>`);
            }
        };

        // ==== Teacher Controls ====
        window.endRound = async function() {
            showInfoModal("Processing...", "<p>Ending round and calculating effects. This may take a moment.</p>");
            
            const batch = writeBatch(db);
            const playersColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`);
            const q = query(playersColRef, where("isTeacher", "==", false));
            const playerDocs = await getDocs(q);

            for (const playerDoc of playerDocs.docs) {
                const pId = playerDoc.id;
                const player = playerDoc.data();
                const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, pId);
                
                const spending = player.domesticSpending || { healthcare: 20, education: 20, infrastructure: 20 };
                const total = spending.healthcare + spending.education + spending.infrastructure;
            
                let happinessChange = 0;
                let incomeModifier = 1.0;
                let unitLosses = { army: 0, navy: 0 };
                let events = [];
                
                if (total >= 75) { happinessChange = 10; incomeModifier = 1.15; events.push("✓ HIGH PROSPERITY: Economy booming! (+15% income)"); } 
                else if (total >= 60) { happinessChange = 5; incomeModifier = 1.05; events.push("✓ Stable conditions (+5% income)"); } 
                else if (total >= 45) { happinessChange = 0; events.push("~ Barely adequate (no changes)"); } 
                else if (total >= 30) { happinessChange = -5; incomeModifier = 0.85; if (Math.random() < 0.2) unitLosses.army = 1; events.push("⚠️ DISCONTENT: Unrest growing (-15% income)"); } 
                else if (total >= 15) { happinessChange = -10; incomeModifier = 0.65; unitLosses.army = Math.floor(Math.random() * 2) + 1; events.push("🚨 CRISIS: Mass protests (-35% income, lost " + unitLosses.army + " army)"); } 
                else { happinessChange = -20; incomeModifier = 0.4; unitLosses.army = 2; events.push("💀 CATASTROPHIC: Revolution imminent! (-60% income, lost 2 army)"); }
                
                if (spending.healthcare < 5) { events.push("🏥 PLAGUE: Healthcare collapsed"); unitLosses.army += 2; incomeModifier *= 0.7; } 
                else if (spending.healthcare < 10) { events.push("🏥 Disease outbreak: Lost units"); unitLosses.army += 1; }
                
                if (spending.education < 5) { events.push("📚 ILLITERACY: Generation lost"); incomeModifier *= 0.5; } 
                else if (spending.education < 10) { events.push("📚 Factory accidents (-20% income)"); incomeModifier *= 0.8; }
                
                if (spending.infrastructure < 5) { events.push("🛤️ COLLAPSE: Cannot trade"); incomeModifier *= 0.5; } 
                else if (spending.infrastructure < 10) { events.push("🛤️ Trade routes severed (-25% income)"); incomeModifier *= 0.75; }

                const newHappiness = Math.max(0, Math.min(200, (player.happinessIndex || 100) + happinessChange));
                const newIncome = Math.max(5, Math.floor((player.income || BASE_INCOME) * incomeModifier));
                const newArmy = Math.max(0, (player.army || 0) - unitLosses.army);
                const newDollars = (player.dollars || 0) + newIncome;

                batch.update(playerRef, {
                    happinessIndex: newHappiness,
                    income: newIncome,
                    army: newArmy,
                    dollars: newDollars,
                    activeEvents: events
                });

                for (const event of events) {
                    const logColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${pId}/log`);
                    const logDocRef = doc(logColRef);
                    batch.set(logDocRef, { message: event, timestamp: serverTimestamp() });
                }
            }

            const gameDocRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}`);
            batch.update(gameDocRef, { phase: 'review' });
            
            await batch.commit();
            closeInfoModal();
        };


        // ==== War Declaration System ====
        async function loadPendingWarDeclarations() {
            const pendingDiv = document.getElementById('pendingWarDeclarations');
            const listDiv = document.getElementById('pendingWarList');
            if (!pendingDiv || !listDiv) return;
            
            const warsQuery = query(
                collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/pendingWars`),
                where('declaringCountry', '==', myCountryName)
            );
            
            const snapshot = await getDocs(warsQuery);
            if (snapshot.empty) {
                pendingDiv.classList.add('hidden');
                return;
            }
            
            pendingDiv.classList.remove('hidden');
            // Build rows so we can handle different statuses (pending, mobilizing, etc.)
            const rows = [];
            snapshot.docs.forEach(d => {
                const data = d.data();
                if (!data) return;

                if (data.status === 'mobilizing') {
                    // If the war is in mobilization, show a button to open/revise mobilization for this war
                    const myMob = (data.mobilizations && data.mobilizations[myCountryName]) || null;
                    rows.push(`<div class="bg-yellow-50 p-3 rounded flex items-center justify-between">
                        <div><strong>${data.declaringCountry}</strong> → Mobilizing</div>
                        <button onclick="showMobilizationPanel('${d.id}')" class="btn btn-warning text-xs">
                            ${myMob?.submitted ? 'Revise Mobilization' : 'Submit Mobilization'}
                        </button>
                    </div>`);
                } else {
                    const targets = Array.isArray(data.targetCountries) ? data.targetCountries.map(t => t.country).join(', ') : (data.targets || []).join(', ');
                    rows.push(`<div class="bg-yellow-50 p-3 rounded">
                        Awaiting approval to declare war on: <strong>${targets}</strong>
                    </div>`);
                }
            });
            listDiv.innerHTML = rows.join('');
        }

        async function loadWarApprovals() {
            const myRoles = getMyRoles();
            const container = document.querySelector('.tab-panel.active');
            if (!container || (!myRoles.includes('Secretary of State') && !myRoles.includes('Minister of Domestic Tranquility'))) return;

            const approvalKey = myRoles.includes('Secretary of State') ? 'secretaryOfState' : 'ministerOfDomestic';
            
            const warsQuery = query(collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/pendingWars`));
            
            const snapshot = await getDocs(warsQuery);
            const needsApproval = snapshot.docs.filter(doc => 
                doc.data().declaringCountry === myCountryName && doc.data().approvals[approvalKey] === false
            );
            
            const listDiv = container.querySelector('.war-approval-list');
            const noApprovalsDiv = container.querySelector('.no-war-approvals');
            
            if (!listDiv || !noApprovalsDiv) return;

            if (needsApproval.length === 0) {
                listDiv.innerHTML = '';
                noApprovalsDiv.classList.remove('hidden');
                return;
            }
            
            noApprovalsDiv.classList.add('hidden');
            listDiv.innerHTML = needsApproval.map(doc => {
                const data = doc.data();
                const targets = data.targetCountries.map(t => t.country).join(', ');
                return `<div class="bg-gray-50 p-4 rounded-lg">
                    <p class="mb-2"><strong>War against:</strong> ${targets}</p>
                    ${data.justification ? `<p class="text-sm text-gray-600 mb-3">"${data.justification}"</p>` : ''}
                    <div class="flex gap-2">
                        <button onclick="approveWar('${doc.id}', true)" class="btn btn-success flex-1">Approve</button>
                        <button onclick="approveWar('${doc.id}', false)" class="btn btn-danger flex-1">Reject</button>
                    </div>
                </div>`;
            }).join('');
        }

        window.approveWar = async function(warId, approved) {
            const myRoles = getMyRoles();
            let approvalKey = '';
            if (myRoles.includes('Secretary of State')) {
                approvalKey = 'approvals.secretaryOfState';
            } else if (myRoles.includes('Minister of Domestic Tranquility')) {
                approvalKey = 'approvals.ministerOfDomestic';
            }
            if (!approvalKey) return;
            
            const warRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/pendingWars`, warId);
            await updateDoc(warRef, {
                [approvalKey]: approved
            });
            
            // Check if both have approved
            const warSnap = await getDoc(warRef);
            const approvals = warSnap.data().approvals;
            
            if (approvals.secretaryOfState === true && approvals.ministerOfDomestic === true) {
                // Move to active wars and notify enemies
                await declareWarFinalized(warId, warSnap.data());
            } else if (approved === false) {
                // Rejected - delete
                await deleteDoc(warRef);
                showInfoModal("Declaration Rejected", "<p>The war declaration has been rejected by a minister.</p>");
                await createLog(`A war declaration against ${warSnap.data().targetCountries.map(t=>t.country).join(', ')} was rejected.`);
            }
            
            await loadWarApprovals();
            await loadPendingWarDeclarations();
        };

        async function declareWarFinalized(warId, warData) {
            // Move to activeWars collection
            const activeWarRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/activeWars`, warId);
            await setDoc(activeWarRef, {
                ...warData,
                status: 'active',
                declaredAt: serverTimestamp()
            });
            
            // Notify all target countries
            for (const target of warData.targetCountries) {
                const notifCol = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${target.playerId}/notifications`);
                await addDoc(notifCol, {
                    type: 'war_declared',
                    from: warData.declaringCountry,
                    message: `⚔️ ${warData.declaringCountry} has declared WAR on your nation!`,
                    timestamp: serverTimestamp()
                });
            }
            
            // Delete pending war
            await deleteDoc(doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/pendingWars`, warId));
            
            showInfoModal("War Declared!", "<p>War has been officially declared. May fortune favor the bold!</p>");
            await createLog(`Our nation has officially declared war on ${warData.targetCountries.map(t=>t.country).join(', ')}.`);
        }
        
        // ==== Role Assignment System ====
        function maybeTriggerRoleAssignment() {
            if (isTeacher || !myCountryName || localGameState.round !== 1) return;
            if (roleAssignmentShown) return;
            // Wait until our player data has loaded locally
            if (!localPlayersState || !localPlayersState[userId]) return;
            
            const countryData = localCountryData[myCountryName];
            const rolesAssigned = countryData?.roleAssignments && 
                Object.keys(countryData.roleAssignments).length > 0;
            
            if (rolesAssigned) return;
            
            const teammates = Object.entries(localPlayersState)
                .filter(([id, player]) => player.country === myCountryName && !player.isTeacher)
                .map(([id, player]) => ({ id, email: player.email, name: player.name }));
            
            if (teammates.length === 0) return;
            
            teammates.sort((a, b) => a.email.localeCompare(b.email));
            const captain = teammates[0];
            
            if (userId !== captain.id) return;
            
            roleAssignmentShown = true;
            showRoleAssignmentModal(teammates);
        }

                // =============== Role Assignment (8) ===============
                window.showRoleAssignmentModal = async function(countryName) {
                    try {
                        const modal = reqEl('roleAssignmentModal');
                        const list = reqEl('roleAssignmentList');
                        list.innerHTML = '<p class="text-gray-500">Loading teammates…</p>';

                        const { playersColRef } = getSimRefs();
                        const qSnap = await getDocs(query(playersColRef, where('country', '==', countryName)));
                        if (qSnap.empty) {
                            list.innerHTML = '<p class="text-gray-500">No players found for this country.</p>';
                            modal.classList.remove('hidden');
                            return;
                        }

                        // Build role assignment rows
                        const availableRoles = STUDENT_ROLES.map(r => r.name);
                        list.innerHTML = '';
                        qSnap.forEach(docSnap => {
                            const pdata = docSnap.data();
                            const currentRole = pdata.role || '';
                            const playerId = docSnap.id;
                            const row = document.createElement('div');
                            row.className = 'flex items-center justify-between bg-white p-3 rounded-lg border';

                            const selectOptions = ['<option value="">-- Select Role --</option>']
                                .concat(
                                    availableRoles.map(r => `<option value="${r}" ${r === currentRole ? 'selected' : ''}>${r}</option>`)
                                )
                                .join('');

                            row.innerHTML = `
                                <div class="flex flex-col">
                                    <span class="font-medium text-gray-800">${pdata.displayName || pdata.email}</span>
                                    <span class="text-xs text-gray-500">${pdata.email || ''}</span>
                                </div>
                                <select class="border border-gray-300 rounded-md px-2 py-1 role-select" data-player-id="${playerId}">
                                    ${selectOptions}
                                </select>
                            `;
                            list.appendChild(row);
                        });

                        reqEl('roleAssignCountryName').textContent = `Assign roles for ${countryName}`;
                        modal.classList.remove('hidden');
                    } catch (err) {
                        console.error('showRoleAssignmentModal error', err);
                        toast(`Failed to open role assignment: ${err.message}`, 'error');
                    }
                };

                // Close modal without saving
                window.closeRoleAssignmentModal = function() {
                    reqEl('roleAssignmentModal').classList.add('hidden');
                };

                // Collect and save role assignments (writes to Firestore)
                window.saveRoleAssignments = async function() {
                    try {
                        const selects = Array.from(document.querySelectorAll('#roleAssignmentList .role-select, #roleAssignmentList select'));

                        if (selects.length === 0) {
                            toast('No role selections found', 'warning');
                            return;
                        }

                        const assignments = selects.map(sel => ({
                            playerId: sel.dataset.playerId || sel.getAttribute('data-player-id'),
                            role: sel.value
                        })).filter(a => a.playerId); // Remove any without IDs

                        // Validate that each required role appears only once
                        const uniqueRoles = new Set();
                        for (const a of assignments) {
                            if (!a.role) continue;
                            if (uniqueRoles.has(a.role)) {
                                toast(`Duplicate role detected: ${a.role}`, 'warning');
                                return;
                            }
                            uniqueRoles.add(a.role);
                        }

                        const { playersColRef, countryDataColRef } = getSimRefs();
                        const batch = writeBatch(db);

                        // If teacher editing, group assignments by country and prepare to write roleAssignments
                        const byCountry = {};
                        for (const { playerId, role } of assignments) {
                            const p = localPlayersState[playerId];
                            if (!p) continue;
                            if (!byCountry[p.country]) byCountry[p.country] = {};
                            // Use email as the key inside country roleAssignments (consistent with loadCountryRoles)
                            byCountry[p.country][p.email] = role;
                        }

                        let updateCount = 0;
                        for (const { playerId, role } of assignments) {
                            if (!playerId) continue;
                            const ref = doc(playersColRef, playerId);
                            // Update BOTH role and roles for consistency
                            batch.update(ref, {
                                role: role || null,
                                roles: role ? [role] : []
                            });
                            updateCount++;
                        }

                        // Update country data with role assignments when teacher used the role editor
                        if (isTeacherEditingRoles) {
                            for (const [country, assigns] of Object.entries(byCountry)) {
                                const cRef = doc(countryDataColRef, country);
                                batch.set(cRef, { roleAssignments: assigns }, { merge: true });
                            }
                        }

                        if (updateCount === 0) {
                            toast('No valid player IDs found to update', 'warning');
                            return;
                        }

                        await batch.commit();

                        // Update local state if present
                        for (const { playerId, role } of assignments) {
                            if (localPlayersState && localPlayersState[playerId]) {
                                localPlayersState[playerId].role = role;
                                localPlayersState[playerId].roles = role ? [role] : [];
                            }
                        }

                        // Reset teacher edit flag
                        isTeacherEditingRoles = false;

                        toast(`Roles successfully saved!`, 'success');
                        closeRoleAssignmentModal();

                    } catch (err) {
                        console.error('saveRoleAssignments error', err);
                        toast(`Failed to save roles: ${err.message}`, 'error');
                    }
                };

        window.showTeacherRoleEditor = async function() {
            isTeacherEditingRoles = true;
            const countries = [...new Set(Object.values(localPlayersState)
                .filter(p => !p.isTeacher)
                .map(p => p.country))];
            
            const modal = document.getElementById('roleAssignmentModal');
            const countryNameEl = document.getElementById('roleAssignCountryName');
            
            const countrySelect = `
                <div class="mb-4">
                    <label class="block font-medium text-gray-700 mb-2">Select Country to Edit:</label>
                    <select id="teacherCountrySelect" class="w-full px-3 py-2 border border-gray-300 rounded-lg">
                        ${countries.map(c => `<option value="${c}">${c}</option>`).join('')}
                    </select>
                </div>
            `;
            
            countryNameEl.innerHTML = countrySelect;
            
            if (countries.length > 0) {
                loadCountryRoles(countries[0]);
            }
            
            setTimeout(() => {
                document.getElementById('teacherCountrySelect').addEventListener('change', (e) => {
                    loadCountryRoles(e.target.value);
                });
            }, 100);
            
            modal.classList.remove('hidden');
        };

        function loadCountryRoles(countryName) {
            const countryData = localCountryData[countryName];
            const currentAssignments = countryData?.roleAssignments || {};

            const teammates = Object.entries(localPlayersState)
                .filter(([id, player]) => player.country === countryName && !player.isTeacher)
                .map(([id, player]) => ({ 
                    id, 
                    email: player.email, 
                    name: player.displayName || player.email,
                    currentRole: currentAssignments[player.email] || player.role || ''
                }));

            console.log(`Loading roles for ${countryName}, found ${teammates.length} players:`, teammates);

            const listEl = document.getElementById('roleAssignmentList');
            listEl.innerHTML = teammates.map(teammate => {
                return `
                <div class="bg-white p-4 rounded-lg border border-gray-200">
                    <div class="flex items-center justify-between mb-2">
                        <div>
                            <div class="font-semibold text-gray-800">${teammate.name}</div>
                            <div class="text-sm text-gray-500">${teammate.email}</div>
                        </div>
                    </div>
                    <select class="w-full px-3 py-2 border border-gray-300 rounded-lg role-select" 
                            data-player-id="${teammate.id}">
                        <option value="">-- No Role Assigned --</option>
                        ${STUDENT_ROLES.map(role => 
                            `<option value="${role.name}" ${role.name === teammate.currentRole ? 'selected' : ''}>
                                ${role.name}
                            </option>`
                        ).join('')}
                    </select>
                </div>
            `}).join('');
            
            console.log('Role assignment selects created:', document.querySelectorAll('.role-select').length);
        }


        function setupStudentTabsWithWar() {
            const myRoles = getMyRoles();
            const tabsContainer = document.getElementById('roleTabs');
            const contentContainer = document.getElementById('roleTabContent');
            tabsContainer.innerHTML = '';
            contentContainer.innerHTML = '';
            
            if (myRoles.length === 0) {
                contentContainer.innerHTML = `<p class="text-gray-500">Your role has not been assigned yet. Please wait for your team captain.</p>`;
                document.getElementById('studentRoleInterface').classList.remove('hidden');
                return;
            }

            const relevantRoles = STUDENT_ROLES.filter(role => myRoles.includes(role.name));

            relevantRoles.forEach((role, index) => {
                const roleId = role.name.replace(/\s+/g, '-');
                const tabButton = document.createElement('button');
                tabButton.className = 'tab-btn' + (index === 0 ? ' active' : '');
                tabButton.textContent = role.name;
                tabButton.dataset.target = roleId;
                tabButton.onclick = () => switchTab(roleId);
                tabsContainer.appendChild(tabButton);

                const tabPanel = document.createElement('div');
                tabPanel.id = roleId;
                tabPanel.className = 'tab-panel space-y-6' + (index === 0 ? ' active' : '');
                
                let templateId = role.contentId;
                if(role.name === 'Secretary of War' && localGameState.round >= 4) {
                    templateId = 'warDeclarationTemplate';
                }

                if (templateId) {
                    const tpl = document.getElementById(templateId);
                    if (tpl) tabPanel.innerHTML = tpl.innerHTML;
                } else if (role.description) {
                     tabPanel.innerHTML = `
                        <div class="card p-6 bg-gray-50">
                            <h3 class="text-xl font-bold text-gray-800 mb-2">${role.name}</h3>
                            <p class="text-gray-600">${role.description}</p>
                        </div>`;
                }

                // Inject war approval section
                if ((role.name === 'Secretary of State' || role.name === 'Minister of Domestic Tranquility') && localGameState.round >= 4) {
                    const warApprovalTemplate = document.getElementById('warApprovalTemplate');
                    const approvalSection = tabPanel.querySelector('#ministerWarApprovalSection, #allianceWarApprovalSection');
                    if (approvalSection && warApprovalTemplate) {
                        approvalSection.innerHTML = warApprovalTemplate.innerHTML;
                        approvalSection.classList.remove('hidden');
                    }
                }

                contentContainer.appendChild(tabPanel);
            });

            document.getElementById('studentRoleInterface').classList.remove('hidden');
            updateWarDeclarationVisibility();
        }

        // Compatibility wrapper used elsewhere in the code
        function setupStudentTabs() {
            setupStudentTabsWithWar();
        }

        function updateWarDeclarationVisibility() {
            const myRoles = getMyRoles();
            const warInterface = document.getElementById('warDeclarationInterface');
            const round = localGameState.round || 1;
            if (warInterface) {
                if (myRoles.includes('Secretary of War') && round >= 4) {
                    warInterface.classList.remove('hidden');
                } else {
                    warInterface.classList.add('hidden');
                }
            }
            loadPendingWarDeclarations().catch(console.error);
            loadWarApprovals().catch(console.error);
        }

        window.showWarDeclarationModal = function() {
            const modal = document.getElementById('warDeclarationModal');
            const enemyList = document.getElementById('enemyAlliancesList');

            // Get my alliance bloc
            const me = localPlayersState[userId] || {};
            const myAllies = Object.keys(me.alliances || {}).filter(id => me.alliances[id]);
            myAllies.push(userId);

            // Group enemies by alliance
            const enemyAlliances = {};
            Object.entries(localPlayersState).forEach(([id, player]) => {
                if (player.isTeacher || myAllies.includes(id)) return;
                const theirAllies = Object.keys(player.alliances || {}).filter(aid => player.alliances[aid]);
                theirAllies.push(id);
                const key = theirAllies.sort().join(',');
                if (!enemyAlliances[key]) enemyAlliances[key] = [];
                enemyAlliances[key].push(player);
            });

            // Render checkboxes
            enemyList.innerHTML = '';
            Object.entries(enemyAlliances).forEach(([key, countries], idx) => {
                const block = document.createElement('div');
                block.className = 'bg-gray-50 p-4 rounded-lg';
                block.innerHTML = `<h5 class="font-semibold text-gray-700 mb-2">Enemy Alliance ${idx + 1}</h5>`;
                
                countries.forEach(country => {
                    const playerId = Object.keys(localPlayersState).find(pid => localPlayersState[pid] === country);
                    block.innerHTML += `
                        <label class="flex items-center p-2 rounded hover:bg-gray-100 cursor-pointer">
                            <input type="checkbox" value="${country.country}" data-player-id="${playerId}" 
                                class="h-5 w-5 rounded border-gray-300 text-red-600 focus:ring-red-500">
                            <span class="ml-3 text-gray-700 font-medium">${country.country} (${country.name})</span>
                            <span class="ml-auto text-sm text-gray-500">Army: ${country.army || 0}, Navy: ${country.navy || 0}</span>
                        </label>`;
                });
                enemyList.appendChild(block);
            });

            modal.classList.remove('hidden');
        };
        
        window.closeWarDeclarationModal = function() {
            document.getElementById('warDeclarationModal').classList.add('hidden');
        };
        function populateAllianceModal() {
            const container = document.getElementById('countryCheckboxes');
            const myData = localPlayersState[userId] || {};
            
            const otherPlayers = Object.entries(localPlayersState)
                .filter(([id, p]) => !p.isTeacher && p.country !== myCountryName);
            
            container.innerHTML = otherPlayers.map(([id, player]) => {
                const isAllied = myData.alliances && myData.alliances[id];
                const restricted = (ALLIANCE_RESTRICTIONS[myCountryName] || []).includes(player.country);
                
                return `
                    <label class="flex items-center p-2 rounded hover:bg-gray-50 ${restricted ? 'opacity-50' : ''}">
                        <input type="checkbox" value="${id}" ${isAllied ? 'checked' : ''} 
                               ${restricted ? 'disabled' : ''}
                               class="h-4 w-4 rounded border-gray-300 text-indigo-600">
                        <span class="ml-2">${player.country} (${player.name})</span>
                        ${restricted ? '<span class="ml-auto text-xs text-red-600">Historical Rivals</span>' : ''}
                    </label>`;
            }).join('');
        }

        window.showAllianceModal = function() {
            populateAllianceModal();
            document.getElementById('allianceModal').classList.remove('hidden');
        };
        window.closeAllianceModal = function() {
            document.getElementById('allianceModal').classList.add('hidden');
        };

        // Submit declaration -> apps/{APP_ID}/simulations/{classCode}/pendingWars/{warId}
        window.submitWarDeclaration = async function() {
            const checked = document.querySelectorAll('#enemyAlliancesList input[type="checkbox"]:checked');
            const selected = Array.from(checked);
            if (selected.length === 0) {
                showInfoModal("No Targets Selected", "<p>Select at least one enemy nation.</p>");
                return;
            }

            const me = localPlayersState[userId] || {};
            const myAllies = Object.keys(me.alliances || {}).filter(id => me.alliances[id]);

            const targets = selected.map(cb => ({ country: cb.value, playerId: cb.dataset.playerId }));

            // Prevent declaring war on current allies
            const alliedTargets = targets.filter(t => myAllies.includes(t.playerId));
            if (alliedTargets.length > 0) {
                const names = alliedTargets.map(t => t.country).join(', ');
                showInfoModal("Allied Nations Selected", `<p>You cannot declare war on current allies: <strong>${names}</strong>. Break the alliance first.</p>`);
                return;
            }

            const justification = (document.getElementById('warJustification')?.value || '').trim();

            try {
                const warDeclaration = {
                    declaringCountry: myCountryName,
                    declaringPlayerId: userId,
                    targetCountries: targets,
                    justification: justification || 'No justification provided',
                    timestamp: serverTimestamp(),
                    approvals: {
                        secretaryOfState: false,
                        ministerOfDomestic: false
                    },
                    status: 'pending',
                    round: localGameState.round || 1
                };

                const warsCol = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/pendingWars`);
                const warRef = doc(warsCol);
                await setDoc(warRef, warDeclaration);

                await notifyApprovers(warRef.id, warDeclaration);

                closeWarDeclarationModal();
                showInfoModal("Submitted", "<p>Your declaration has been submitted for approval.</p>");
                await loadPendingWarDeclarations();
            } catch (e) {
                console.error('submitWarDeclaration failed:', e);
                showInfoModal("Error", `<p>${e?.message || 'Something went wrong.'}</p>`);
            }
        };

        window.purchaseUnits = async function(unitType, context) {
            const quantityEl = document.getElementById(`${unitType}Quantity-${context}`);
            const quantity = parseInt(quantityEl.value);
            if (isNaN(quantity) || quantity <= 0) {
                showInfoModal("Invalid Quantity", "<p>Please enter a valid number of units to purchase.</p>");
                return;
            }
            
            const cost = unitType === 'army' ? 750 : 1000;
            const totalCost = quantity * cost;

            const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, userId);

            try {
                await runTransaction(db, async (transaction) => {
                    const playerDoc = await transaction.get(playerRef);
                    if (!playerDoc.exists()) {
                        throw "Player data not found!";
                    }
                    const playerData = playerDoc.data();
                    const militaryBudget = (playerData.dollars * (playerData.militaryBudgetPercentage / 100));
                    const remainingBudget = militaryBudget - (playerData.militarySpendingThisRound || 0);

                    // Defensive: require a valid remaining pool and enough funds
                    if (!isFinite(remainingBudget) || remainingBudget <= 0 || totalCost > remainingBudget) {
                        throw `Not enough military funds. Need $${totalCost.toLocaleString()}, have $${isFinite(remainingBudget) ? remainingBudget.toLocaleString() : '0'}.`;
                    }

                    const newUnitCount = (playerData[unitType] || 0) + quantity;
                    const newSpending = (playerData.militarySpendingThisRound || 0) + totalCost;
                    
                    transaction.update(playerRef, {
                        [unitType]: newUnitCount,
                        militarySpendingThisRound: newSpending
                    });
                });
                showInfoModal("Purchase Successful", `<p>You have purchased ${quantity} ${unitType} unit(s).</p>`);
                createLog(`Purchased ${quantity} ${unitType} unit(s).`);
            } catch (error) {
                console.error("Purchase failed:", error);
                showInfoModal("Purchase Failed", `<p>${error.toString()}</p>`);
            }
        };

        window.setMilitaryBudget = async function(value) {
            const percentage = parseInt(value);
            document.getElementById('militaryBudgetPercentageDisplay').textContent = `${percentage}%`;
            const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, userId);
            try {
                await updateDoc(playerRef, { militaryBudgetPercentage: percentage });
                 createLog(`Set military budget allocation to ${percentage}%.`);
            } catch(e) {
                console.error("Failed to set military budget", e);
            }
        };

        // Download CSV template
        window.downloadTemplate = function() {
            const csvContent = "Email,Country,Period\nstudent1@example.com,Tobermory,1\nstudent2@example.com,Metz,1";
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const url = URL.createObjectURL(blob);
            link.setAttribute("href", url);
            link.setAttribute("download", "roster_template.csv");
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        };

        // Upload and parse CSV
        window.uploadCSV = async function() {
            const fileInput = document.getElementById('csvFile');
            const file = fileInput.files[0];
            
            if (!file) {
                showInfoModal("No File Selected", "<p>Please select a CSV file to upload.</p>");
                return;
            }
            
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const text = e.target.result;
                    const lines = text.split('\n').map(line => line.trim()).filter(line => line);
                    
                    // Skip header row
                    const dataLines = lines.slice(1);
                    
                    if (dataLines.length === 0) {
                        showInfoModal("Empty File", "<p>The CSV file contains no student data.</p>");
                        return;
                    }
                    
                    const batch = writeBatch(db);
                    let successCount = 0;
                    let errors = [];
                    
                    for (const line of dataLines) {
                        const parts = line.split(',').map(p => p.trim());
                        const email = parts[0];
                        const country = parts[1];
                        const period = parts[2] || '';
                        
                        if (!email || !country) {
                            errors.push(`Skipped invalid row: ${line}`);
                            continue;
                        }
                        
                        // Validate country
                        if (!getDefaultStartingBudget(country)) {
                            errors.push(`Invalid country "${country}" for ${email}`);
                            continue;
                        }
                        
                        const rosterRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/roster`, email);
                        batch.set(rosterRef, {
                            email: email,
                            country: country,
                            period: period,
                            addedAt: serverTimestamp()
                        });
                        successCount++;
                    }
                    
                    await batch.commit();
                    
                    let message = `<p>Successfully added ${successCount} student(s) to the roster.</p>`;
                    if (errors.length > 0) {
                        message += `<p class="mt-3 text-sm text-red-600">Errors:</p><ul class="text-xs list-disc list-inside">`;
                        errors.forEach(err => {
                            message += `<li>${err}</li>`;
                        });
                        message += `</ul>`;
                    }
                    
                    showInfoModal("CSV Upload Complete", message);
                    await loadExistingRoster();
                    fileInput.value = '';
                    
                } catch (error) {
                    console.error("CSV parsing error:", error);
                    showInfoModal("Upload Failed", `<p>Failed to parse CSV: ${error.message}</p>`);
                }
            };
            
            reader.readAsText(file);
        };

        // ...existing code...

        // Remove selected students
        window.removeSelectedStudents = async function() {
            const checkboxes = document.querySelectorAll('#rosterList input[type="checkbox"]:checked');
            
            if (checkboxes.length === 0) {
                showInfoModal("No Selection", "<p>Please select students to remove.</p>");
                return;
            }
            
            const confirmed = await showConfirmModal(
                "Remove Students?",
                `<p>Remove ${checkboxes.length} student(s) from the roster?</p>`
            );
            
            if (!confirmed) return;
            
            try {
                const batch = writeBatch(db);
                
                checkboxes.forEach(checkbox => {
                    const email = checkbox.value;
                    const rosterRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/roster`, email);
                    batch.delete(rosterRef);
                });
                
                await batch.commit();
                showInfoModal("Students Removed", `<p>${checkboxes.length} student(s) removed from roster.</p>`);
                await loadExistingRoster();
                
            } catch (error) {
                console.error("Failed to remove students:", error);
                showInfoModal("Error", `<p>Failed to remove students: ${error.message}</p>`);
            }
        };

        // Start simulation with selected period
        window.startSimulationDirectly = async function() {
            const selectedPeriod = document.getElementById('classPeriodSelect').value;
            
            if (!selectedPeriod) {
                showInfoModal("No Period Selected", "<p>Please select a class period to start.</p>");
                return;
            }
            
            const confirmed = await showConfirmModal(
                "Start Simulation?",
                `<p>Start the simulation for Period ${selectedPeriod}?</p>
                 <p class="text-sm text-gray-600 mt-2">Students in this period will be initialized with their starting budgets and resources.</p>`
            );
            
            if (!confirmed) return;
            
            try {
                // Get all students in the selected period
                const rosterColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/roster`);
                const q = query(rosterColRef, where('period', '==', selectedPeriod));
                const snapshot = await getDocs(q);
                
                if (snapshot.empty) {
                    showInfoModal("No Students", `<p>No students found in Period ${selectedPeriod}.</p>`);
                    return;
                }
                
                const batch = writeBatch(db);
                
                // Initialize each student
                snapshot.forEach(docSnap => {
                    const studentData = docSnap.data();
                    const country = studentData.country;
                    
                    // Note: We don't create player docs here - they're created when students join
                    // Just ensure the country data exists
                    const countryRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/countryData`, country);
                    batch.set(countryRef, {
                        pnp: 100,
                        roleAssignments: {}
                    }, { merge: true });
                });
                
                // Set the simulation as active for this period
                const gameDocRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}`);
                batch.set(gameDocRef, {
                    activePeriod: selectedPeriod,
                    round: 1,
                    phase: 'waiting'
                }, { merge: true });
                
                await batch.commit();
                
                // Hide roster screen, show game
                document.getElementById('rosterScreen').classList.add('hidden');
                document.getElementById('gameContainer').classList.remove('hidden');
                
                setupFirestoreListeners();
                
                showInfoModal("Simulation Started", 
                    `<p>Simulation started for Period ${selectedPeriod}!</p>
                     <p class="text-sm text-gray-600 mt-2">Students can now join using class code: <strong>${currentClassCode}</strong></p>`);
                
            } catch (error) {
                console.error("Failed to start simulation:", error);
                showInfoModal("Error", `<p>Failed to start simulation: ${error.message}</p>`);
            }
        };

        // Clear all roster entries
        window.clearAllRoster = async function() {
            const confirmed = await showConfirmModal(
                "Clear Entire Roster?",
                "<p class='text-red-600 font-semibold'>This will remove ALL students from the roster.</p><p class='mt-2'>This action cannot be undone.</p>"
            );
            
            if (!confirmed) return;
            
            // Double confirmation for destructive action
            const doubleConfirmed = await showConfirmModal(
                "Are You Absolutely Sure?",
                "<p>This will permanently delete all roster data.</p>"
            );
            
            if (!doubleConfirmed) return;
            
            try {
                const rosterColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/roster`);
                const snapshot = await getDocs(rosterColRef);
                
                const batch = writeBatch(db);
                snapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                
                await batch.commit();
                
                showInfoModal("Roster Cleared", "<p>All students have been removed from the roster.</p>");
                await loadExistingRoster();
                
            } catch (error) {
                console.error("Failed to clear roster:", error);
                showInfoModal("Error", `<p>Failed to clear roster: ${error.message}</p>`);
            }
        };
        window.planColonization = async function(key) {
            const territory = COLONIAL_TERRITORIES[key];
            const myData = localPlayersState[userId] || {};
            
            if ((myData.dollars || 0) < territory.cost) {
                showInfoModal("Insufficient Funds", `<p>You need $${territory.cost.toLocaleString()} to attempt this colonization.</p>`);
                return;
            }
            
            const confirmed = await showConfirmModal(
                "Plan Colonization?",
                `<p>Pay $${territory.cost.toLocaleString()} now to attempt colonizing ${territory.name}?</p>
                 <p class="text-sm text-gray-600 mt-2">Success is determined at end of round (50% chance)</p>`
            );
            
            if (!confirmed) return;
            
            const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, userId);
            
            try {
                await runTransaction(db, async (transaction) => {
                    const playerDoc = await transaction.get(playerRef);
                    const player = playerDoc.data();
                    
                    if (player.dollars < territory.cost) {
                        throw "Insufficient funds!";
                    }
                    
                    transaction.update(playerRef, {
                        dollars: player.dollars - territory.cost,
                        [`colonialPlans.${key}`]: territory
                    });
                });
                
                showInfoModal("Colonization Planned", `<p>You have invested in attempting to colonize ${territory.name}. Results will be revealed at the end of the round.</p>`);
                await createLog(`Invested $${territory.cost.toLocaleString()} to attempt colonizing ${territory.name}.`);
            } catch (error) {
                showInfoModal("Failed", `<p>${error.toString()}</p>`);
            }
        };
        window.proposeAlliance = async function() {
            const checkboxes = document.querySelectorAll('#countryCheckboxes input[type="checkbox"]:checked');
            const selectedIds = Array.from(checkboxes).map(cb => cb.value);

            if (selectedIds.length === 0) {
                showInfoModal("No Selection", "<p>Please select at least one country to ally with.</p>");
                return;
            }

            // For each selected target, create a notification in their notifications collection
            for (const targetId of selectedIds) {
                const notifCol = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${targetId}/notifications`);
                await addDoc(notifCol, {
                    type: 'alliance_request',
                    fromPlayerId: userId,
                    fromCountry: localPlayersState[userId]?.country || 'Unknown',
                    message: `${localPlayersState[userId]?.country || 'A nation'} has proposed an alliance with you.`,
                    timestamp: serverTimestamp()
                });
            }

            closeAllianceModal();
            showInfoModal("Proposals Sent", "<p>Alliance proposals have been sent to selected nations.</p>");
            await createLog(`Sent alliance proposals to ${selectedIds.length} nation(s).`);
        };

        window.acceptAllianceRequest = async function(notificationId, fromPlayerId) {
            // Set alliance flag on both players
            const myRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, userId);
            const otherRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, fromPlayerId);

            const batch = writeBatch(db);
            batch.update(myRef, { [`alliances.${fromPlayerId}`]: true });
            batch.update(otherRef, { [`alliances.${userId}`]: true });

            // Remove the notification
            const notifRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${userId}/notifications`, notificationId);
            batch.delete(notifRef);

            await batch.commit();

            closeStudentNotificationModal();
            showInfoModal("Alliance Formed", `<p>You are now allied with ${localPlayersState[fromPlayerId]?.country || 'a nation'}.</p>`);
            await createLog(`Accepted alliance with ${localPlayersState[fromPlayerId]?.country || fromPlayerId}.`);
        };

        window.rejectAllianceRequest = async function(notificationId, fromPlayerId) {
            const notifRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${userId}/notifications`, notificationId);
            await deleteDoc(notifRef);
            closeStudentNotificationModal();
            showInfoModal("Alliance Rejected", `<p>You rejected the alliance proposal from ${localPlayersState[fromPlayerId]?.country || fromPlayerId}.</p>`);
            await createLog(`Rejected alliance with ${localPlayersState[fromPlayerId]?.country || fromPlayerId}.`);
        };
        window.startRound = async function() {
            const timerMinutes = parseInt(document.getElementById('timerMinutes').value) || 15;
            const timerEnds = new Date(Date.now() + timerMinutes * 60000);
            
            const gameDocRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}`);
            await updateDoc(gameDocRef, {
                phase: 'active',
                timerEnds: timerEnds
            });
            
            // Reset military spending for all players
            const playersColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`);
            const snapshot = await getDocs(query(playersColRef, where("isTeacher", "==", false)));
            const batch = writeBatch(db);
            snapshot.docs.forEach(d => {
                batch.update(d.ref, { militarySpendingThisRound: 0 });
            });
            await batch.commit();
        };
        window.resolveColonialChance = async function() {
            showInfoModal("Processing...", "<p>Resolving colonial attempts...</p>");
            
            const playersColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`);
            const snapshot = await getDocs(query(playersColRef, where("isTeacher", "==", false)));
            
            const batch = writeBatch(db);
            let results = [];
            
            for (const playerDoc of snapshot.docs) {
                const player = playerDoc.data();
                const plans = player.colonialPlans || {};
                
                for (const [key, plan] of Object.entries(plans)) {
                    const territory = COLONIAL_TERRITORIES[key];
                    if (!territory) continue;
                    const roll = Math.random() * 100;
                    const success = roll < 50; // 50% chance
                    
                    if (success) {
                        batch.update(playerDoc.ref, {
                            [`colonies.${key}`]: territory,
                            [`colonialPlans.${key}`]: null,
                            income: (player.income || BASE_INCOME) + territory.income
                        });
                        results.push(`${player.country} successfully colonized ${territory.name}!`);
                        
                        const logColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${playerDoc.id}/log`);
                        const logDocRef = doc(logColRef);
                        batch.set(logDocRef, {
                            message: `Successfully colonized ${territory.name}! (+${territory.income} income)`,
                            timestamp: serverTimestamp()
                        });
                    } else {
                        batch.update(playerDoc.ref, {
                            [`colonialPlans.${key}`]: null
                        });
                        results.push(`${player.country} failed to colonize ${territory.name}.`);
                        
                        const logColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${playerDoc.id}/log`);
                        const logDocRef = doc(logColRef);
                        batch.set(logDocRef, {
                            message: `Failed to colonize ${territory.name}. Funds lost.`,
                            timestamp: serverTimestamp()
                        });
                    }
                }
            }
            
            await batch.commit();
            closeInfoModal();
            showInfoModal("Colonial Results", `<div class="space-y-2">${results.map(r => `<p>${r}</p>`).join('')}</div>`);
        };
        window.checkAlliances = async function() {
            showInfoModal("Checking Alliances", "<p>Validating all alliances for historical accuracy...</p>");
            
            const playersColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`);
            const snapshot = await getDocs(query(playersColRef, where("isTeacher", "==", false)));
            
            const batch = writeBatch(db);
            let violations = [];
            
            snapshot.docs.forEach(playerDoc => {
                const player = playerDoc.data();
                const allies = Object.keys(player.alliances || {}).filter(id => player.alliances[id]);
                
                allies.forEach(allyId => {
                    const ally = localPlayersState[allyId];
                    if (ally) {
                        const restricted = ALLIANCE_RESTRICTIONS[player.country] || [];
                        if (restricted.includes(ally.country)) {
                            violations.push(`${player.country} cannot ally with ${ally.country} (historical rivals)`);
                            batch.update(playerDoc.ref, {
                                [`alliances.${allyId}`]: false
                            });
                        }
                    }
                });
            });
            
            await batch.commit();
            closeInfoModal();
            
            if (violations.length > 0) {
                showInfoModal("Alliance Violations", 
                    `<div class="space-y-2">${violations.map(v => `<p class="text-red-600">${v}</p>`).join('')}</div>`);
            } else {
                showInfoModal("Alliances Valid", "<p>All alliances are historically acceptable.</p>");
            }
        };
        window.nextRound = async function() {
            try {
                const { simRef, playersColRef } = getSimRefs();
                // Load current round
                const simSnap = await getDoc(simRef);
                const curRound = Number(simSnap.exists() ? (simSnap.data().round || 1) : 1);

                // Apply income + reset round fields + clear activeEvents
                await forEachDocInBatches(playersColRef, async (d, batch) => {
                    const p = d.data();
                    if (p.isTeacher) return;
                    const income = computeIncomeForPlayer(p);
                    const newDollars = Number(p.dollars || 0) + income * 1000; // scale into currency units
                    batch.update(d.ref, {
                        dollars: newDollars,
                        militarySpendingThisRound: 0,
                        activeEvents: []
                    });
                });

                await updateDoc(simRef, { round: curRound + 1, phase: 'waiting', timerStartedAt: null, timerDurationMinutes: null, timerEnds: null });
                showInfoModal("Round Advanced", `<p>Now starting Round ${curRound + 1}</p>`);
            } catch (err) {
                console.error('nextRound error', err);
                toast(`Failed to advance round: ${err.message}`, 'error');
            }
        };
        window.showStudentDemoModal = () => { alert('Show student demo clicked'); };
        window.exitStudentDemo = () => { alert('Exit demo clicked'); };
        window.showPnpPanel = function() {
            const select = document.getElementById('pnpCountry');
            select.innerHTML = '<option value="">-- Select a Country --</option>';
            Object.values(localPlayersState)
                .filter(p => !p.isTeacher)
                .forEach(p => {
                    select.innerHTML += `<option value="${p.country}">${p.country}</option>`;
                });
            document.getElementById('pnpPanel').classList.remove('hidden');
        };

        window.closePnpPanel = function() {
            document.getElementById('pnpPanel').classList.add('hidden');
        };

        window.handleReasonChange = function() {
            const dropdown = document.getElementById('pnpReasonDropdown');
            const reasonInput = document.getElementById('pnpReason');
            if (!dropdown || !reasonInput) return;
            if (dropdown.value === 'Custom') {
                reasonInput.value = '';
                reasonInput.focus();
            } else if (dropdown.value) {
                reasonInput.value = dropdown.value;
            }
        };

        window.awardPnpToCountry = async function() {
            const country = document.getElementById('pnpCountry').value;
            const amount = parseInt(document.getElementById('pnpAmount').value);
            const reason = document.getElementById('pnpReason').value;
            
            if (!country || !amount || !reason) {
                showInfoModal("Missing Info", "<p>Please fill all fields.</p>");
                return;
            }
            
            // Find all players in that country
            const countryPlayers = Object.entries(localPlayersState)
                .filter(([id, p]) => p.country === country && !p.isTeacher);
            
            const batch = writeBatch(db);
            
            for (const [playerId, player] of countryPlayers) {
                const playerRef = doc(db, `apps/${APP_ID}/simulations/${currentClassCode}/players`, playerId);
                batch.update(playerRef, {
                    pnp: (player.pnp || 100) + amount
                });
                
                const logColRef = collection(db, `apps/${APP_ID}/simulations/${currentClassCode}/players/${playerId}/log`);
                const logDocRef = doc(logColRef);
                batch.set(logDocRef, {
                    message: `PNP ${amount > 0 ? 'awarded' : 'deducted'}: ${amount} (${reason})`,
                    timestamp: serverTimestamp()
                });
            }
            
            await batch.commit();
            closePnpPanel();
            showInfoModal("Success", `<p>Adjusted PNP for ${country} by ${amount}.</p>`);
        };
        window.exportResults = async function() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            doc.setFontSize(20);
            doc.text('The North - Game Results', 20, 20);
            doc.setFontSize(12);
            doc.text(`Class: ${currentClassCode}`, 20, 30);
            doc.text(`Round: ${localGameState.round || 1}`, 20, 40);
            
            // Get all players sorted by score
            const playersArray = Object.values(localPlayersState)
                .filter(p => !p.isTeacher)
                .map(p => {
                    const basePnp = (localCountryData[p.country]?.pnp || 100) + (p.pnp - 100);
                    const armyPnp = (p.army || 0) * 750;
                    const navyPnp = (p.navy || 0) * 1000;
                    const coloniesPnp = Object.values(p.colonies || {}).reduce((sum, c) => sum + (c.cost || 0), 0);
                    return {
                        country: p.country,
                        name: p.name,
                        score: basePnp + armyPnp + navyPnp + coloniesPnp,
                        army: p.army || 0,
                        navy: p.navy || 0,
                        dollars: p.dollars || 0
                    };
                })
                .sort((a, b) => b.score - a.score);
            
            // Create table
            const tableData = playersArray.map((p, i) => [
                i + 1,
                p.country,
                p.name,
                p.score.toLocaleString(),
                p.army,
                p.navy,
                '$' + p.dollars.toLocaleString()
            ]);
            
            doc.autoTable({
                head: [['Rank', 'Country', 'Player', 'Total PNP', 'Army', 'Navy', 'Budget']],
                body: tableData,
                startY: 50
            });
            
            doc.save(`the-north-results-${currentClassCode}-round-${localGameState.round || 1}.pdf`);
            showInfoModal("Export Complete", "<p>Results have been downloaded as PDF.</p>");
        };
        // Helper to delete all documents in a collection in chunks
        async function deleteCollection(colRef, chunkSize = 250) {
            const qSnap = await getDocs(colRef);
            const docs = qSnap.docs;
            for (let i = 0; i < docs.length; i += chunkSize) {
                const batch = writeBatch(db);
                for (const d of docs.slice(i, i + chunkSize)) batch.delete(d.ref);
                await batch.commit();
            }
        }

        window.resetGame = async function() {
            const confirmed = await showConfirmModal(
                "Reset Game?",
                "<p>This will delete ALL game data (players, roster, country data, wars, logs). This cannot be undone. Proceed?</p>"
            );
            if (!confirmed) return;

            const base = `apps/${APP_ID}/simulations/${currentClassCode}`;

            try {
                // Delete top-level subcollections
                await deleteCollection(collection(db, `${base}/players`));
                await deleteCollection(collection(db, `${base}/roster`));
                await deleteCollection(collection(db, `${base}/countryData`));
                await deleteCollection(collection(db, `${base}/warDeclarations`));
                // activeWars or other collections
                try { await deleteCollection(collection(db, `${base}/activeWars`)); } catch(e) {}

                // Clean nested per-player collections if any (logs/notifications)
                const playersSnap = await getDocs(collection(db, `${base}/players`));
                for (const p of playersSnap.docs) {
                    try { await deleteCollection(collection(db, `${base}/players/${p.id}/log`)); } catch(e) {}
                    try { await deleteCollection(collection(db, `${base}/players/${p.id}/notifications`)); } catch(e) {}
                }

                // Finally delete the game doc
                await deleteDoc(doc(db, `apps/${APP_ID}/simulations/${currentClassCode}`));
                window.location.reload();
            } catch (error) {
                console.error('Reset failed:', error);
                showInfoModal('Reset Failed', `<p>Could not reset game: ${error.message}</p>`);
            }
        };
        
                // =============== Hour Selection (7) ===============
                // Opens the modal and lists available class hours based on roster docs
                window.showHourSelection = async function() {
                    try {
                        const modal = reqEl('hourSelectionModal');
                        const list = reqEl('availableHours');
                        list.innerHTML = '<div class="text-gray-500">Loading hours…</div>';

                        const { rosterColRef } = getSimRefs();
                        const snap = await getDocs(rosterColRef);

                        const counts = new Map();
                        snap.forEach(d => {
                            const p = (d.data().period ?? '').toString().trim();
                            if (!p) return; // ignore unassigned
                            counts.set(p, (counts.get(p) || 0) + 1);
                        });

                        // Build hours 1..12; show counts if present; selectable if count>0
                        const hours = Array.from({ length: 12 }, (_, i) => String(i + 1));
                        list.innerHTML = '';
                        hours.forEach(h => {
                            const c = counts.get(h) || 0;
                            const disabled = c === 0 ? 'disabled' : '';
                            const note = c === 0
                                ? '<span class="text-xs text-gray-400">(no roster)</span>'
                                : `<span class="text-xs text-gray-600">(${c} students)</span>`;
                            const row = document.createElement('label');
                            row.className = `flex items-center justify-between p-3 rounded-lg border bg-white ${c===0 ? 'opacity-50' : ''}`;
                            row.innerHTML = `
                                <div class="flex items-center gap-3">
                                    <input type="radio" name="selectedHour" value="${h}" class="h-4 w-4 text-indigo-600" ${disabled} onchange="hourSelectionChanged()">
                                    <span class="font-medium">Period ${h}</span>
                                </div>
                                ${note}
                            `;
                            list.appendChild(row);
                        });

                        // reset button state
                        const btn = reqEl('startWithHourBtn');
                        btn.disabled = true;

                        modal.classList.remove('hidden');
                    } catch (err) {
                        console.error('showHourSelection error', err);
                        toast(`Failed to load hours: ${err.message}`, 'error');
                    }
                };

                // Handle radio change; enable start button
                window.hourSelectionChanged = function() {
                    const btn = reqEl('startWithHourBtn');
                    const chosen = document.querySelector('input[name="selectedHour"]:checked');
                    btn.disabled = !chosen;
                };

                // Close modal without changes
                window.closeHourSelection = function() {
                    reqEl('hourSelectionModal').classList.add('hidden');
                };

                // Start the simulation for the selected hour (period)
                window.startSimulationWithHour = async function() {
                    try {
                        const chosen = document.querySelector('input[name="selectedHour"]:checked');
                        if (!chosen) { toast('Select a class period first.', 'warning'); return; }
                        const period = chosen.value;
                        const { simRef } = getSimRefs();

                        await setDoc(simRef, {
                            currentPeriod: period,
                            round: 1,
                            phase: 'waiting',
                            timerStartedAt: null,
                            timerDurationMinutes: null,
                            timerEnds: null
                        }, { merge: true });

                        // Reflect in UI similarly to startSimulationDirectly
                        toast(`Simulation set to Period ${period}.`, 'success');
                        reqEl('hourSelectionModal').classList.add('hidden');

                        // If we are on the roster screen, transition to game/teacher view
                        const roster = document.getElementById('rosterScreen');
                        if (roster && !roster.classList.contains('hidden')) {
                            roster.classList.add('hidden');
                            document.getElementById('gameContainer').classList.remove('hidden');
                            document.getElementById('teacherPanel').classList.remove('hidden');
                            reqEl('displayClassCode').textContent = currentClassCode;
                            reqEl('displayPlayerName').textContent = user?.displayName || user?.email || 'Teacher';
                            setupFirestoreListeners?.();
                        }
                    } catch (err) {
                        console.error('startSimulationWithHour error', err);
                        toast(`Failed to start for selected hour: ${err.message}`, 'error');
                    }
                };

                // Optional convenience: open hour selection if roster dropdown empty
                window.maybeShowHourSelection = function() {
                    const sel = document.getElementById('classPeriodSelect');
                    if (!sel) return;
                    const hasOptions = sel.querySelectorAll('option').length > 1; // beyond placeholder
                    if (!hasOptions) showHourSelection();
                };
        
                // =============== MOBILIZATION SYSTEM ===============

                // When war is approved, transition to mobilization
                async function startMobilizationPhase(warId) {
                    try {
                        const { warDeclarationsColRef } = getSimRefs();
                        const warRef = doc(warDeclarationsColRef, warId);
                        const warSnap = await getDoc(warRef);
                        const warData = warSnap.data();
                
                        // Determine all nations involved
                        const attackers = [warData.declaringCountry];
                        const defenders = warData.targets || [];
                
                        // Get allies for each side
                        const attackingAlliance = await getAllianceMembers(warData.declaringCountry);
                        const defendingAlliance = new Set();
                        for (const target of defenders) {
                            const allies = await getAllianceMembers(target);
                            allies.forEach(a => defendingAlliance.add(a));
                        }
                
                        // Read configurable mobilization minutes from teacher panel; fall back to 15
                        let configuredMinutes = 15;
                        try {
                            const el = document.getElementById('mobilizationMinutes');
                            const v = parseInt(el?.value);
                            if (!isNaN(v) && v >= 1) configuredMinutes = v;
                        } catch (e) { /* ignore */ }

                        const mobilizationDeadline = new Date(Date.now() + configuredMinutes * 60000);
                
                        await updateDoc(warRef, {
                            status: 'mobilizing',
                            alliances: {
                                attacking: Array.from(attackingAlliance),
                                defending: Array.from(defendingAlliance)
                            },
                            mobilizationDeadline,
                            mobilizations: {}
                        });
                
                        // Notify all Secretaries of War
                        const allNations = [...attackingAlliance, ...defendingAlliance];
                        for (const country of allNations) {
                            const players = getCountryPlayers(country);
                            for (const [pid, pdata] of players) {
                                const roles = Array.isArray(pdata.roles) ? pdata.roles : (pdata.role ? [pdata.role] : []);
                                if (roles.includes('Secretary of War')) {
                                        await sendNotification(pid, {
                                        type: 'mobilization_required',
                                        warId,
                                        message: `WAR! Mobilize your forces immediately. You have ${configuredMinutes} minutes.`
                                    });
                                }
                            }
                        }
                
                        toast('Mobilization phase started. All nations must commit forces.', 'success');
                    } catch (err) {
                        console.error('startMobilizationPhase error', err);
                        toast(`Failed to start mobilization: ${err.message}`, 'error');
                    }
                }

                        // Handle a mobilization deadline: teacher can auto-progress the war to 'in_battle'
                        async function handleMobilizationDeadline(warId, warData) {
                            if (!isTeacher) throw new Error('Only teachers may auto-progress wars');
                            try {
                                const { warDeclarationsColRef, basePath } = getSimRefs();
                                const warRef = doc(warDeclarationsColRef, warId);

                                // Refresh snapshot to ensure we have the latest
                                const snap = await getDoc(warRef);
                                if (!snap.exists()) throw new Error('War declaration not found');
                                const data = snap.data();

                                // Move to activeWars collection with status
                                const activeWarRef = doc(db, `${basePath}/activeWars`, warId);
                                await setDoc(activeWarRef, { ...data, status: 'active', declaredAt: serverTimestamp() });

                                // Notify all involved players (attackers and defenders) about active war
                                const allCountries = new Set();
                                if (data.declaringCountry) allCountries.add(data.declaringCountry);
                                (data.targets || []).forEach(t => allCountries.add(t));
                                // include allies if present in data.alliances
                                (data.alliances?.attacking || []).forEach(c => allCountries.add(c));
                                (data.alliances?.defending || []).forEach(c => allCountries.add(c));

                                for (const country of allCountries) {
                                    for (const [pid, pdata] of getCountryPlayers(country)) {
                                        try {
                                            await sendNotification(pid, {
                                                type: 'war_declared',
                                                warId,
                                                from: data.declaringCountry,
                                                message: `⚔️ ${data.declaringCountry} has declared war on ${Array.isArray(data.targets)?data.targets.join(', '):data.targets}. Mobilization ended.`
                                            });
                                        } catch (e) { console.warn('notify player failed', pid, e); }
                                    }
                                }

                                // Delete the pending/mobilizing declaration
                                await deleteDoc(warRef);

                                // Optionally log for teacher
                                await createLog(`Auto-progressed war ${warId} to active status.`, userId);
                            } catch (err) {
                                console.error('handleMobilizationDeadline error', err);
                                throw err;
                            }
                        }

                        // Expose for debugging
                        Object.assign(window, { handleMobilizationDeadline });

                // Get all allied nations for a country
                async function getAllianceMembers(countryName) {
                    const members = new Set([countryName]);
                    const alliances = safeGet(localCountryData, countryName, 'alliances') || {};
            
                    for (const [ally, status] of Object.entries(alliances)) {
                        if (status === 'accepted') {
                            members.add(ally);
                            // Recursively get their allies too
                            const theirAlliances = safeGet(localCountryData, ally, 'alliances') || {};
                            for (const [secondOrder, secondStatus] of Object.entries(theirAlliances)) {
                                if (secondStatus === 'accepted') members.add(secondOrder);
                            }
                        }
                    }
            
                    return members;
                }

                // Expose helpers for external callers/tests
                Object.assign(window, { getAllianceMembers, startMobilizationPhase });

                // Show mobilization panel for Secretary of War
                window.showMobilizationPanel = async function(warId) {
                    try {
                        const { warDeclarationsColRef } = getSimRefs();
                        const warRef = doc(warDeclarationsColRef, warId);
                        const warSnap = await getDoc(warRef);
                        const warData = warSnap.data();
                
                        const me = localPlayersState[userId];
                        const myCountry = me.country;
                        const myAlliance = (warData.alliances?.attacking || []).includes(myCountry) ? 'attacking' : 'defending';
                        const allyCountries = warData.alliances?.[myAlliance] || [];
                
                        // Get current mobilization if exists
                        const currentMob = warData.mobilizations?.[myCountry] || {
                            army: [0, 0, 0],
                            navy: [0, 0, 0],
                            submitted: false
                        };
                
                        const modal = reqEl('mobilizationModal');
                        const content = reqEl('mobilizationContent');
                
                        // Build ally summary
                        let allyHTML = '<div class="bg-blue-50 p-4 rounded-lg mb-4"><h4 class="font-semibold mb-2">Your Alliance Forces:</h4><div class="space-y-1">';
                        for (const country of allyCountries) {
                            const countryPlayers = Object.values(localPlayersState).filter(p => p.country === country);
                            const totalArmy = countryPlayers.reduce((sum, p) => sum + (p.army || 0), 0);
                            const totalNavy = countryPlayers.reduce((sum, p) => sum + (p.navy || 0), 0);
                            const mob = warData.mobilizations?.[country];
                            const status = mob?.submitted ? '✓ Ready' : '⏳ Pending';
                            allyHTML += `<div class="text-sm"><strong>${country}:</strong> ${totalArmy} Army, ${totalNavy} Navy <span class="text-xs">${status}</span></div>`;
                        }
                        allyHTML += '</div></div>';
                
                        const myArmy = me.army || 0;
                        const myNavy = me.navy || 0;
                
                        content.innerHTML = `
                            <h3 class="text-2xl font-bold text-red-800 mb-4">⚔️ MOBILIZATION ORDERS</h3>
                    
                            ${allyHTML}
                    
                            <div class="bg-red-50 border-2 border-red-300 rounded-lg p-4 mb-4">
                                <p class="font-semibold text-red-800">ALL units must be committed to battle!</p>
                                <p class="text-sm text-red-700">Victory requires winning 4 of 6 battles. Losing battles means losing those units permanently.</p>
                            </div>
                    
                            <div class="grid grid-cols-2 gap-4 mb-4">
                                <div class="bg-gray-100 p-3 rounded">
                                    <div class="text-sm text-gray-600">Your Army Units</div>
                                    <div class="text-2xl font-bold">${myArmy}</div>
                                </div>
                                <div class="bg-gray-100 p-3 rounded">
                                    <div class="text-sm text-gray-600">Your Navy Units</div>
                                    <div class="text-2xl font-bold">${myNavy}</div>
                                </div>
                            </div>
                    
                            <div class="space-y-4">
                                <div class="mb-3 text-sm text-gray-700">
                                    Mobilization deadline: <span id="mobilizationCountdown">--:--</span>
                                </div>
                                <div>
                                    <h4 class="font-semibold mb-2">Army Battles (${myArmy} total)</h4>
                                    <div class="grid grid-cols-3 gap-2">
                                        <div>
                                            <label class="text-xs">Battle 1</label>
                                            <input type="number" id="armyBattle1" min="0" max="${myArmy}" value="${currentMob.army[0]}" 
                                                   class="w-full px-2 py-1 border rounded" onchange="validateMobilization()">
                                        </div>
                                        <div>
                                            <label class="text-xs">Battle 2</label>
                                            <input type="number" id="armyBattle2" min="0" max="${myArmy}" value="${currentMob.army[1]}" 
                                                   class="w-full px-2 py-1 border rounded" onchange="validateMobilization()">
                                        </div>
                                        <div>
                                            <label class="text-xs">Battle 3</label>
                                            <input type="number" id="armyBattle3" min="0" max="${myArmy}" value="${currentMob.army[2]}" 
                                                   class="w-full px-2 py-1 border rounded" onchange="validateMobilization()">
                                        </div>
                                    </div>
                                    <div id="armyTotal" class="text-sm mt-1"></div>
                                </div>
                        
                                <div>
                                    <h4 class="font-semibold mb-2">Naval Battles (${myNavy} total)</h4>
                                    <div class="grid grid-cols-3 gap-2">
                                        <div>
                                            <label class="text-xs">Battle 1</label>
                                            <input type="number" id="navyBattle1" min="0" max="${myNavy}" value="${currentMob.navy[0]}" 
                                                   class="w-full px-2 py-1 border rounded" onchange="validateMobilization()">
                                        </div>
                                        <div>
                                            <label class="text-xs">Battle 2</label>
                                            <input type="number" id="navyBattle2" min="0" max="${myNavy}" value="${currentMob.navy[1]}" 
                                                   class="w-full px-2 py-1 border rounded" onchange="validateMobilization()">
                                        </div>
                                        <div>
                                            <label class="text-xs">Battle 3</label>
                                            <input type="number" id="navyBattle3" min="0" max="${myNavy}" value="${currentMob.navy[2]}" 
                                                   class="w-full px-2 py-1 border rounded" onchange="validateMobilization()">
                                        </div>
                                    </div>
                                    <div id="navyTotal" class="text-sm mt-1"></div>
                                </div>
                            </div>
                    
                            <div class="mt-6 flex justify-end gap-3">
                                <button class="btn btn-secondary" onclick="closeMobilizationModal()">Cancel</button>
                                <button id="submitMobBtn" class="btn btn-danger" onclick="submitMobilization('${warId}')" disabled>
                                    Submit Mobilization
                                </button>
                            </div>
                        `;
                
                        modal.classList.remove('hidden');
                        validateMobilization(); // Initial validation

                        // Start countdown timer for mobilization modal
                        try {
                            // Clear any existing countdown interval to avoid duplicates
                            if (window._mobilizationCountdownInterval) {
                                clearInterval(window._mobilizationCountdownInterval);
                                window._mobilizationCountdownInterval = null;
                            }
                            const updateCountdown = () => {
                                const warRefLocal = warRef;
                                getDoc(warRefLocal).then(snap => {
                                    const w = snap.data();
                                    const deadline = w?.mobilizationDeadline ? new Date(w.mobilizationDeadline.seconds ? w.mobilizationDeadline.seconds * 1000 : w.mobilizationDeadline) : null;
                                    const el = reqEl('mobilizationCountdown');
                                    if (!deadline || !el) return;
                                    const ms = deadline - Date.now();
                                    if (ms <= 0) {
                                        el.textContent = '00:00';
                                        if (window._mobilizationCountdownInterval) {
                                            clearInterval(window._mobilizationCountdownInterval);
                                            window._mobilizationCountdownInterval = null;
                                        }
                                        return;
                                    }
                                    const mins = Math.floor(ms / 60000);
                                    const secs = Math.floor((ms % 60000) / 1000);
                                    el.textContent = `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
                                }).catch(()=>{});
                            };
                            updateCountdown();
                            window._mobilizationCountdownInterval = setInterval(updateCountdown, 1000);
                        } catch (e) { /* ignore */ }
                
                    } catch (err) {
                        console.error('showMobilizationPanel error', err);
                        toast(`Failed to show mobilization: ${err.message}`, 'error');
                    }
                };

                window.validateMobilization = function() {
                    const me = localPlayersState[userId];
                    const myArmy = me.army || 0;
                    const myNavy = me.navy || 0;
            
                    const army1 = parseInt(reqEl('armyBattle1').value) || 0;
                    const army2 = parseInt(reqEl('armyBattle2').value) || 0;
                    const army3 = parseInt(reqEl('armyBattle3').value) || 0;
                    const armySum = army1 + army2 + army3;
            
                    const navy1 = parseInt(reqEl('navyBattle1').value) || 0;
                    const navy2 = parseInt(reqEl('navyBattle2').value) || 0;
                    const navy3 = parseInt(reqEl('navyBattle3').value) || 0;
                    const navySum = navy1 + navy2 + navy3;
            
                    const armyTotalEl = reqEl('armyTotal');
                    const navyTotalEl = reqEl('navyTotal');
                    const submitBtn = reqEl('submitMobBtn');
            
                    const armyValid = armySum === myArmy;
                    const navyValid = navySum === myNavy;
            
                    armyTotalEl.textContent = armyValid 
                        ? `✓ Total: ${armySum}/${myArmy}` 
                        : `✗ Total: ${armySum}/${myArmy} (must equal ${myArmy})`;
                    armyTotalEl.className = armyValid ? 'text-sm text-green-600 font-semibold' : 'text-sm text-red-600 font-semibold';
            
                    navyTotalEl.textContent = navyValid 
                        ? `✓ Total: ${navySum}/${myNavy}` 
                        : `✗ Total: ${navySum}/${myNavy} (must equal ${myNavy})`;
                    navyTotalEl.className = navyValid ? 'text-sm text-green-600 font-semibold' : 'text-sm text-red-600 font-semibold';
            
                    submitBtn.disabled = !(armyValid && navyValid);
                };

                window.submitMobilization = async function(warId) {
                    try {
                        const me = localPlayersState[userId];
                        const myCountry = me.country;
                
                        const mobilization = {
                            army: [
                                parseInt(reqEl('armyBattle1').value) || 0,
                                parseInt(reqEl('armyBattle2').value) || 0,
                                parseInt(reqEl('armyBattle3').value) || 0
                            ],
                            navy: [
                                parseInt(reqEl('navyBattle1').value) || 0,
                                parseInt(reqEl('navyBattle2').value) || 0,
                                parseInt(reqEl('navyBattle3').value) || 0
                            ],
                            submitted: true,
                            submittedAt: serverTimestamp(),
                            submittedBy: userId
                        };
                
                        const { warDeclarationsColRef } = getSimRefs();
                        const warRef = doc(warDeclarationsColRef, warId);
                
                        await updateDoc(warRef, {
                            [`mobilizations.${myCountry}`]: mobilization
                        });
                
                        toast('Mobilization submitted. Good luck in battle!', 'success');
                        closeMobilizationModal();
                
                    } catch (err) {
                        console.error('submitMobilization error', err);
                        toast(`Failed to submit: ${err.message}`, 'error');
                    }
                };

                window.closeMobilizationModal = function() {
                                    reqEl('mobilizationModal')?.classList.add('hidden');
                                    if (window._mobilizationCountdownInterval) {
                                        clearInterval(window._mobilizationCountdownInterval);
                                        window._mobilizationCountdownInterval = null;
                                    }
                };

                // ================= TEACHER WAR MANAGEMENT =================
                window.showTeacherWarManagement = async function() {
                    try {
                        const { warDeclarationsColRef } = getSimRefs();
                        const mobilizingWars = await getDocs(query(warDeclarationsColRef, where('status', 'in', ['mobilizing', 'in_battle'])));
                
                        if (mobilizingWars.empty) {
                            showInfoModal('No Active Wars', '<p>No wars currently in progress.</p>');
                            return;
                        }
                
                        let html = '<div class="space-y-4">';
                
                        mobilizingWars.forEach(warDoc => {
                            const war = warDoc.data();
                                const allSubmitted = Object.values(war.mobilizations || {}).every(m => m.submitted);

                                // Summarize total mobilized forces per side for teacher view
                                const attackingForces = Object.entries(war.mobilizations || {})
                                    .filter(([country]) => (war.alliances?.attacking || []).includes(country))
                                    .reduce((sum, [, mob]) => ({
                                        army: sum.army + (Array.isArray(mob.army) ? mob.army.reduce((a,b)=>a+b,0) : 0),
                                        navy: sum.navy + (Array.isArray(mob.navy) ? mob.navy.reduce((a,b)=>a+b,0) : 0)
                                    }), {army: 0, navy: 0});

                                const defendingForces = Object.entries(war.mobilizations || {})
                                    .filter(([country]) => (war.alliances?.defending || []).includes(country))
                                    .reduce((sum, [, mob]) => ({
                                        army: sum.army + (Array.isArray(mob.army) ? mob.army.reduce((a,b)=>a+b,0) : 0),
                                        navy: sum.navy + (Array.isArray(mob.navy) ? mob.navy.reduce((a,b)=>a+b,0) : 0)
                                    }), {army: 0, navy: 0});

                                const summaryHtml = `<div class="text-sm mb-2">\n                                <strong>Attacking:</strong> ${attackingForces.army} Army, ${attackingForces.navy} Navy | \n                                <strong>Defending:</strong> ${defendingForces.army} Army, ${defendingForces.navy} Navy\n                            </div>`;
                    
                            html += `
                                <div class="border-2 border-red-300 rounded-lg p-4 bg-red-50">
                                    <h4 class="font-bold text-lg mb-2">
                                        ${war.alliances.attacking.join(', ')} vs ${war.alliances.defending.join(', ')}
                                    </h4>
                                    <div class="text-sm mb-3">
                                        Status: <span class="font-semibold">${war.status}</span>
                                    </div>
                            
                                    ${war.status === 'mobilizing' ? `
                                        ${summaryHtml}
                                        <div class="bg-white p-3 rounded mb-2 max-h-48 overflow-y-auto">
                                            <h5 class="font-semibold text-sm mb-1">Mobilizations:</h5>
                                            ${Object.entries(war.mobilizations || {}).map(([country, mob]) => `
                                                <div class="text-xs border-b pb-1 mb-1">
                                                    <strong>${country}</strong> ${mob.submitted ? '✓' : '⏳'}
                                                    ${mob.submitted ? `<br/>Army: [${mob.army.join(', ')}] | Navy: [${mob.navy.join(', ')}]` : ''}
                                                </div>
                                            `).join('')}
                                        </div>
                                        ${allSubmitted ? `
                                            <button onclick="beginPhysicalBattle('${warDoc.id}')" class="btn btn-danger w-full">
                                                Begin Physical Battle
                                            </button>
                                        ` : '<p class="text-sm text-gray-600">Waiting for all mobilizations...</p>'}
                                    ` : ''}
                            
                                    ${war.status === 'in_battle' ? `
                                        <button onclick="enterBattleResults('${warDoc.id}')" class="btn btn-warning w-full">
                                            Enter Battle Results
                                        </button>
                                    ` : ''}
                                </div>
                            `;
                        });
                
                        html += '</div>';
                        showInfoModal('Active Wars', html);
                
                    } catch (err) {
                        console.error('showTeacherWarManagement error', err);
                        toast(`Failed to load wars: ${err.message}`, 'error');
                    }
                };

                window.beginPhysicalBattle = async function(warId) {
                    try {
                        const { warDeclarationsColRef } = getSimRefs();
                        await updateDoc(doc(warDeclarationsColRef, warId), {
                            status: 'in_battle',
                            battleStartedAt: serverTimestamp()
                        });
                
                        toast('Battle status updated. Conduct physical battle now.', 'success');
                        closeInfoModal();
                    } catch (err) {
                        console.error('beginPhysicalBattle error', err);
                        toast(`Failed: ${err.message}`, 'error');
                    }
                };

                window.enterBattleResults = async function(warId) {
                    const { warDeclarationsColRef } = getSimRefs();
                    const warSnap = await getDoc(doc(warDeclarationsColRef, warId));
                    const war = warSnap.data();
            
                    const html = `
                        <h3 class="text-xl font-bold mb-4">Enter Battle Results</h3>
                        <div class="space-y-3">
                            ${['Army Battle 1', 'Army Battle 2', 'Army Battle 3', 'Naval Battle 1', 'Naval Battle 2', 'Naval Battle 3'].map((name, i) => `
                                <div class="border p-3 rounded">
                                    <div class="font-semibold mb-2">${name}</div>
                                    <label class="flex items-center">
                                        <input type="radio" name="battle${i}" value="attacking" class="mr-2">
                                        Attacking Alliance Won
                                    </label>
                                    <label class="flex items-center">
                                        <input type="radio" name="battle${i}" value="defending" class="mr-2">
                                        Defending Alliance Won
                                    </label>
                                </div>
                            `).join('')}
                        </div>
                        <button onclick="finalizeBattleResults('${warId}')" class="btn btn-success w-full mt-4">
                            Finalize War Results
                        </button>
                    `;
            
                    showInfoModal('Battle Results', html);
                };

                window.finalizeBattleResults = async function(warId) {
                    try {
                        const results = [];
                        for (let i = 0; i < 6; i++) {
                            const winner = document.querySelector(`input[name="battle${i}"]:checked`)?.value;
                            if (!winner) {
                                toast(`Please select winner for battle ${i+1}`, 'warning');
                                return;
                            }
                            results.push(winner);
                        }
                
                        const attackingWins = results.filter(r => r === 'attacking').length;
                        const defendingWins = results.filter(r => r === 'defending').length;
                        const winningAlliance = attackingWins >= 4 ? 'attacking' : 'defending';
                
                        const { warDeclarationsColRef, playersColRef } = getSimRefs();
                        const warRef = doc(warDeclarationsColRef, warId);
                        const warSnap = await getDoc(warRef);
                        const war = warSnap.data();
                
                        // Deduct ALL units from all participants (they all committed everything)
                        const batch = writeBatch(db);
                        const allCountries = [...war.alliances.attacking, ...war.alliances.defending];
                
                        for (const country of allCountries) {
                            const countryPlayers = Object.values(localPlayersState).filter(p => p.country === country);
                            for (const player of countryPlayers) {
                                const pRef = doc(playersColRef, Object.keys(localPlayersState).find(k => localPlayersState[k] === player));
                                batch.update(pRef, {
                                    army: 0,
                                    navy: 0
                                });
                            }
                        }
                
                        // Determine game winner (highest PNP on winning side)
                        let highestPNP = 0;
                        let gameWinner = null;
                        const winningCountries = war.alliances[winningAlliance];
                
                        for (const country of winningCountries) {
                            const countryPlayers = Object.values(localPlayersState).filter(p => p.country === country);
                            for (const player of countryPlayers) {
                                const pnp = calculateTotalPnp(player);
                                if (pnp > highestPNP) {
                                    highestPNP = pnp;
                                    gameWinner = country;
                                }
                            }
                        }
                
                        batch.update(warRef, {
                            status: 'concluded',
                            battleResults: results,
                            winningAlliance,
                            gameWinner,
                            concludedAt: serverTimestamp()
                        });
                
                        await batch.commit();
                
                        showInfoModal('WAR CONCLUDED', `
                            <div class="text-center space-y-4">
                                <h3 class="text-3xl font-bold text-red-800">VICTORY!</h3>
                                <p class="text-xl">${winningAlliance === 'attacking' ? 'Attacking' : 'Defending'} Alliance Wins</p>
                                <p class="text-2xl font-bold text-indigo-800">
                                    GAME WINNER: ${gameWinner}
                                </p>
                                <p class="text-sm text-gray-600">
                                    Score: ${highestPNP.toLocaleString()} PNP
                                </p>
                                <p class="text-sm text-gray-500 mt-4">
                                    All units from all nations have been lost in the war.
                                </p>
                            </div>
                        `);

                        // Notify all participants (students) that the war has concluded
                        const failedNotifications = [];
                        for (const country of allCountries) {
                            for (const [pid] of getCountryPlayers(country)) {
                                try {
                                    await sendNotification(pid, {
                                        type: 'war_concluded',
                                        message: `War concluded! ${winningAlliance === 'attacking' ? 'Attackers' : 'Defenders'} won. Game winner: ${gameWinner}`
                                    });
                                } catch (e) {
                                    console.warn('Failed to send war_concluded notification to', pid, e?.message || e);
                                    failedNotifications.push(pid);
                                }
                            }
                        }
                        if (failedNotifications.length) {
                            toast(`Warning: ${failedNotifications.length} player(s) didn't receive war conclusion notification`, 'warning');
                        }
                
                    } catch (err) {
                        console.error('finalizeBattleResults error', err);
                        toast(`Failed to finalize: ${err.message}`, 'error');
                    }
                };
        
    </script>
    <script>
        // Embedded war declaration object (readable by other scripts as window.warDeclarations)
        // Status flow: pending → approved → mobilizing → in_battle → concluded
        window.warDeclarations = {
            status: 'mobilizing',
            alliances: {
                attacking: ['Tobermory', 'Grenoble'],
                defending: ['Metz', 'Klagenfurt', 'Tivoli']
            },
            mobilizations: {
                Tobermory: { army: [10, 10, 10], navy: [5, 5, 5], submitted: true },
                Grenoble: { army: [8, 8, 9], navy: [4, 4, 4], submitted: false }
                // add other nations here as needed
            },
            // ISO 8601 timestamp for mobilization deadline
            mobilizationDeadline: '2025-10-13T00:00:00Z',
            battleResults: {
                armyBattle1: { winner: 'attacking', attackSurvivors: 15, defendSurvivors: 0 },
                armyBattle2: null,
                armyBattle3: null,
                navyBattle1: null,
                navyBattle2: null,
                navyBattle3: null
            },
            winningAlliance: null, // 'attacking' or 'defending'
            gameWinner: null // country name of highest PNP on winning side
        };
    </script>

    <!-- Mobilization Modal -->


</body>
</html>
